# 统计编程基础

## 引言

在大语言模型（LLM）成为强大编程助手的今天，编程教育的重心正在发生根本性的转移。死记硬背语法和API细节的价值确实在大幅降低。这一变革标志着编程教育从"技能导向"向"思维导向"的深刻转型。过去，编程教学往往过分强调记忆各种语言的语法规则、函数库的API细节，以及特定框架的使用方法，学生需要花费大量时间在机械记忆上。然而，随着Deepseek等AI编程助手的普及，这些原本需要记忆的知识点现在可以通过简单的自然语言查询即时获得。这并不意味着编程变得不重要，恰恰相反，它意味着编程教育的价值需要重新定位。

在新的AI时代，编程教育的核心价值不再体现在"知道多少语法"，而是体现在"能够解决什么问题"和"如何设计解决方案"。学生需要培养的是更高层次的思维能力：如何将一个复杂的现实问题分解成计算机可以处理的步骤，如何选择合适的算法和数据结构，如何设计清晰的系统架构，如何与AI进行有效协作以验证和优化代码质量。这些能力构成了AI时代统计编程人员的核心竞争力。

具体而言，统计编程教育应该着重培养以下几个关键能力：首先是问题分解与抽象建模能力，这要求学生能够将复杂的统计问题转化为可计算的数学模型；其次是算法思维，理解不同统计方法的计算原理和适用条件；再次是数据处理能力，从数据收集、清洗到分析的完整流程设计；最后是与AI协作的能力，包括精准提问、代码审查和迭代优化。这些能力的培养需要项目驱动的教学方法，让学生在解决真实统计问题的过程中逐步建立编程思维框架。

这种教育重心的转移对学生提出了新的要求，也带来了新的机遇。学生不再需要为记忆琐碎的语法细节而苦恼，可以将更多精力投入到统计建模和数据分析中。教师的教学方法也需要相应调整，从传统的"语法讲解+练习题"模式转向"统计项目实践+计算思维训练"模式。通过这种转变，统计编程教育将更好地服务于培养学生的数据科学思维和统计分析能力这一根本目标，为他们在AI时代的科研和数据分析工作奠定坚实基础。

现在，对学生来说，最重要的不再是"如何写代码"，而是"解决什么问题"和"为何这样解决"。

本章将介绍AI时代的编程思维框架，帮助学生培养与LLM协同工作的核心能力，并通过R语言实践掌握现代数据分析方法。

## 核心能力培养框架

以下是学生在学习编程课程时最需要培养的核心技能，我将其分为三大类：

### 一、高阶思维与问题解决能力（LLM难以替代的）

这是最核心、最根本的能力，是驾驭LLM的"方向盘"。

#### 1. 问题分解与抽象建模能力

**是什么**：将一个复杂的、模糊的现实世界问题，分解成一个个清晰的、可执行的小模块或算法步骤的能力。这种能力不仅涉及技术层面的分解，更包含对问题本质的深刻理解和抽象思维。在生态学研究中，这意味着能够将复杂的生态系统现象转化为可计算、可分析的数学模型和算法流程。

**为什么重要**：LLM可以帮你写for循环，但它无法替你决定"整个系统应该分成哪几个微服务"或"这个业务流程应该如何用状态图表示"。这是人类工程师最核心的价值。在AI时代，这种能力变得更加关键，因为LLM擅长执行具体任务，但缺乏对复杂问题的整体把握和战略规划能力。学生需要学会如何将模糊的研究问题转化为清晰的算法需求，这样才能有效指导LLM完成具体实现。

**生态学案例**：分析森林生态系统的物种多样性变化，需要分解为：数据收集、数据清洗、多样性指数计算、统计分析、结果可视化等步骤。具体而言，这个过程可以进一步细化为：首先确定研究目标和数据需求，包括样地选择标准、调查方法和数据格式；然后设计数据收集方案，考虑野外调查的可行性和数据质量控制；接着制定数据清洗流程，处理缺失值、异常值和数据标准化问题；再选择合适的多样性指数计算方法，如Shannon-Wiener指数、Simpson指数等，并考虑其生态学意义；最后设计统计分析框架和可视化方案，确保结果能够清晰反映生态学规律。

这种问题分解能力在生态学研究中尤为重要，因为生态系统的复杂性往往超出直觉理解。通过系统性的分解和抽象，研究者能够将看似混沌的自然现象转化为有序的分析流程。例如，在研究气候变化对物种分布的影响时，需要将问题分解为气候数据获取、物种分布数据整合、生态位模型构建、未来情景预测等多个模块，每个模块都有其特定的技术要求和生态学考量。

培养这种能力的关键在于实践和反思。学生应该通过具体的生态学项目，学习如何识别问题的核心要素，如何设计合理的分析流程，以及如何在技术实现和生态学意义之间找到平衡。随着经验的积累，这种问题分解和抽象建模能力将成为学生在AI时代进行生态学研究的核心竞争力。

#### 2. 算法与数据结构思维

**是什么**：理解不同算法和数据结构的适用场景、时间/空间复杂度（Big O Notation）。知道何时使用哈希表而不是数组，何时采用动态规划而不是暴力破解。

**为什么重要**：LLM可以根据你的要求实现一个排序算法，但你必须告诉它"我需要一个原地排序、时间复杂度为O(n log n)的算法"。你具备这种思维，才能给LLM发出正确的指令，并评判它给出的方案优劣。

**生态学案例**：处理大规模的物种分布数据时，需要选择合适的数据结构来高效存储和查询。

#### 3. 系统设计与架构能力

**是什么**：从宏观视角设计软件的整体结构，包括模块划分、通信机制、数据流、技术选型（选择正确的工具和框架）等。

**为什么重要**：LLM是"砖瓦匠"，但你是"建筑师"。建筑师负责画出蓝图，决定哪里承重、哪里开窗，砖瓦匠（LLM）则负责高效地砌好每一面墙。

### 二、与LLM协同工作的能力（新时代的核心技能）

将LLM视为一个强大的、但需要精确引导的合作伙伴。

#### 1. 精确提问与Prompt工程能力

**是什么**：能够清晰、无歧义地向LLM描述你的需求、约束条件和上下文。这不仅仅是技术，更是一门沟通艺术。

**示例**：
- 糟糕的提问："帮我写个排序代码"
- 优秀的提问："用R写一个快速排序函数，输入是数字向量，要求是原地排序并返回排序后的列表。请为关键步骤添加注释"

#### 2. 代码审查与批判性验证能力

**是什么**：LLM生成的代码可能有错误、过时、不安全或效率低下。学生必须具备火眼金睛，能审查、测试、调试和验证LLM输出的代码。

**为什么重要**：盲目相信LLM的输出是极其危险的。你必须能问："这个方案真的最优吗？有没有边界情况没考虑？这个API是不是已经弃用了？"

#### 3. 迭代与优化能力

**是什么**：LLM很少能一次生成完美答案。你需要根据它的输出进行反馈、修正和迭代，像"对话"一样逐步完善解决方案。

**示例**："你刚才生成的函数处理异常情况不够，请添加try-catch逻辑。" "这个查询性能有点慢，能否优化索引？"

### 三、传统但愈发重要的软技能

这些技能在AI时代反而更加凸显其价值。

#### 1. 调试与故障排查能力

当系统在一个复杂分布式环境中出错时，LLM很难直接定位根因。强大的调试能力（分析日志、使用诊断工具、逻辑推理）至关重要。

#### 2. 沟通与协作能力

你需要向非技术的团队成员解释技术方案，也需要和同事协同设计大型系统。LLM无法替你开会、写设计文档或统一团队思想。

#### 3. 持续学习与好奇心

技术栈和LLM本身都在飞速迭代。今天的最佳实践明天可能就过时了。保持好奇心和学习欲望，是避免被淘汰的关键。

## 模块一：通用编程思维基础

### 编程核心概念

#### 变量与常量

```r
# 变量就像可擦写的白板，可以随时修改
score <- 90
score <- 95  # 可以修改

# 常量就像刻在石头上的字，一旦设定就不能改变
PI <- 3.14159
# PI <- 3.14  # 不应该修改常量
```

**为什么重要**：没有变量就像每次都要重新写数字，无法复用；没有常量就像用容易擦掉的字写重要信息，可能被意外修改。

#### 基本数据类型

```r
# 数字类型
temperature <- 25.5
count <- 100L

# 逻辑类型
is_raining <- TRUE
is_sunny <- FALSE

# 字符类型
species_name <- "Quercus acutissima"
habitat <- "deciduous forest"

# 空值
missing_data <- NULL
```

**为什么重要**：不知道数据类型就像分不清积木形状，无法正确组合。不同类型有不同的操作方式，混淆会导致错误。

#### 集合数据类型

```r
# 向量 - 同类型元素的集合
temperatures <- c(20, 22, 25, 18, 23)
species <- c("Oak", "Pine", "Maple", "Birch")

# 列表 - 可以包含不同类型的元素
forest_data <- list(
  name = "Tianmu Mountain Forest",
  area = 428,
  dominant_species = c("Cyclobalanopsis", "Castanopsis"),
  elevation_range = c(300, 1500)
)

# 数据框 - 表格形式的数据
forest_df <- data.frame(
  plot_id = 1:5,
  species = c("Quercus", "Pinus", "Acer", "Betula", "Fagus"),
  dbh = c(25.3, 18.7, 12.4, 15.8, 22.1),
  height = c(18.2, 15.6, 10.3, 12.7, 16.9)
)
```

**为什么重要**：用错集合类型就像用碗装水或用杯子吃饭，效率低下。不同集合适合不同用途，正确选择提高效率和可读性。

#### 分支与循环

```r
# 条件判断 - 根据条件选择不同路径
classify_tree_size <- function(dbh) {
  if (dbh < 10) {
    return("sapling")
  } else if (dbh < 30) {
    return("medium tree")
  } else {
    return("large tree")
  }
}

# 循环 - 重复执行操作
# 计算每个样地的平均胸径
plot_dbh <- c(15.3, 22.7, 18.4, 25.1, 12.9)
average_dbh <- numeric(length(plot_dbh))

for (i in 1:length(plot_dbh)) {
  average_dbh[i] <- mean(plot_dbh[1:i])
}

# 更R风格的方式 - 使用向量化操作
average_dbh <- cumsum(plot_dbh) / 1:length(plot_dbh)
```

### 算法思维培养

#### 问题分解与步骤化思考

**生态学案例**：统计森林样地中不同树种的多样性指数

1. **数据收集**：读取样地调查数据
2. **数据清洗**：处理缺失值和异常值
3. **物种计数**：统计每个物种的个体数
4. **多样性计算**：计算Shannon-Wiener指数、Simpson指数等
5. **结果可视化**：绘制多样性图表

```r
# 示例：计算物种多样性
calculate_diversity <- function(species_data) {
  # 步骤1：统计每个物种的频数
  species_counts <- table(species_data)

  # 步骤2：计算总个体数
  total_individuals <- sum(species_counts)

  # 步骤3：计算每个物种的比例
  species_proportions <- species_counts / total_individuals

  # 步骤4：计算Shannon多样性指数
  shannon_index <- -sum(species_proportions * log(species_proportions))

  # 步骤5：计算Simpson多样性指数
  simpson_index <- 1 - sum(species_proportions^2)

  return(list(
    shannon = shannon_index,
    simpson = simpson_index,
    richness = length(species_counts)
  ))
}

# 使用示例
sample_species <- c("Oak", "Pine", "Oak", "Maple", "Pine", "Birch", "Oak")
diversity_results <- calculate_diversity(sample_species)
print(diversity_results)
```

#### 模式识别与规律发现

```r
# 分析温度数据的季节性模式
# 假设我们有12个月的月平均温度数据
monthly_temps <- c(3.2, 5.1, 10.3, 16.8, 21.5, 25.3,
                   28.7, 27.9, 23.4, 17.6, 10.8, 4.9)
months <- 1:12

# 识别最高温和最低温
max_temp <- max(monthly_temps)
min_temp <- min(monthly_temps)
max_month <- which.max(monthly_temps)
min_month <- which.min(monthly_temps)

cat(sprintf("最高温度: %.1f°C (月份: %d)\n", max_temp, max_month))
cat(sprintf("最低温度: %.1f°C (月份: %d)\n", min_temp, min_month))

# 计算年平均温度
annual_mean <- mean(monthly_temps)
cat(sprintf("年平均温度: %.1f°C\n", annual_mean))
```

### 编程思维实践

#### 模块化思维：函数封装与单一职责原则

```r
# 不好的做法：一个函数做太多事情
process_forest_data_bad <- function(data_file) {
  # 读取数据、清洗数据、分析数据、画图都在一个函数里
  data <- read.csv(data_file)
  data <- na.omit(data)
  diversity <- calculate_diversity(data$species)
  plot(diversity$shannon)
  return(diversity)
}

# 好的做法：每个函数只做一件事
read_forest_data <- function(file_path) {
  # 只负责读取数据
  data <- read.csv(file_path)
  return(data)
}

clean_forest_data <- function(data) {
  # 只负责数据清洗
  data <- na.omit(data)
  data <- data[data$dbh > 0, ]  # 去除异常值
  return(data)
}

analyze_diversity <- function(species_vector) {
  # 只负责多样性分析
  return(calculate_diversity(species_vector))
}

# 主函数协调各个模块
process_forest_data_good <- function(data_file) {
  raw_data <- read_forest_data(data_file)
  clean_data <- clean_forest_data(raw_data)
  results <- analyze_diversity(clean_data$species)
  return(results)
}
```

#### 接口设计思维：清晰的输入输出规范

```r
# 定义清晰的函数接口
calculate_tree_volume <- function(
  dbh,           # 胸径(cm)，数值向量
  height,        # 树高(m)，数值向量
  species_type = "broadleaf"  # 树种类型，可选"broadleaf"或"conifer"
) {
  # 输入验证
  if (length(dbh) != length(height)) {
    stop("dbh和height的长度必须相同")
  }

  if (!species_type %in% c("broadleaf", "conifer")) {
    stop("species_type必须是'broadleaf'或'conifer'")
  }

  # 根据树种类型选择不同的体积公式
  if (species_type == "broadleaf") {
    # 阔叶树体积公式
    volume <- 0.00006 * dbh^2 * height
  } else {
    # 针叶树体积公式
    volume <- 0.00005 * dbh^2 * height
  }

  # 返回结果
  return(volume)
}

# 使用示例
dbh_values <- c(25, 30, 35, 40)
height_values <- c(15, 18, 20, 22)
volumes <- calculate_tree_volume(dbh_values, height_values, "broadleaf")
print(volumes)
```

## 模块二：LLM协同编程技能

### 精准提问技巧

#### Prompt工程基本原则

**生态学数据分析的Prompt示例**：

```
请用R语言帮我分析森林样地数据：

数据描述：
- 数据框包含以下列：plot_id（样地编号）、species（物种名称）、dbh（胸径）、height（树高）
- 数据已保存在CSV文件中，路径为"data/forest_survey.csv"

分析要求：
1. 读取数据并检查数据质量（缺失值、异常值）
2. 计算每个样地的物种丰富度（物种数）
3. 计算每个样地的平均胸径和平均树高
4. 绘制物种丰富度与平均胸径的关系散点图
5. 使用ggplot2进行可视化，添加适当的标题和标签

请为关键步骤添加注释，并确保代码具有良好的可读性。
```

#### 上下文提供与约束条件设定

**改进的Prompt示例**：

```
我正在分析天目山森林动态监测样地的数据，需要计算生物多样性指数。

约束条件：
- 数据包含200个固定样地的调查结果
- 每个样地面积为20m×20m
- 只统计DBH≥1cm的木本植物
- 需要排除外来物种和栽培物种

具体要求：
1. 计算每个样地的Shannon-Wiener多样性指数
2. 计算每个样地的Simpson多样性指数
3. 分析多样性指数与海拔的相关性
4. 生成专业的研究报告图表

请使用vegan包进行多样性计算，确保代码符合生态学研究的标准做法。
```

### 代码审查能力

#### LLM输出代码的常见错误类型

```r
# LLM可能生成的有问题的代码示例
# 问题1：缺乏错误处理
calculate_density <- function(area, count) {
  density <- count / area  # 如果area为0会出错
  return(density)
}

# 改进版本
calculate_density_safe <- function(area, count) {
  if (area <= 0) {
    stop("面积必须大于0")
  }
  density <- count / area
  return(density)
}

# 问题2：使用过时的函数
# LLM可能推荐使用旧的函数版本
old_way <- read.table("data.csv")  # 较老的函数

# 改进：使用更现代的tidyverse方法
library(tidyverse)
modern_way <- read_csv("data.csv")  # 更简洁的语法
```

#### 功能正确性验证方法

```r
# 创建测试用例验证函数正确性
test_diversity_calculation <- function() {
  # 测试用例1：单一物种
  single_species <- rep("Oak", 10)
  result1 <- calculate_diversity(single_species)

  # 单一物种的Shannon指数应该为0
  if (abs(result1$shannon - 0) > 1e-10) {
    stop("单一物种测试失败")
  }

  # 测试用例2：两个物种各占一半
  two_species <- rep(c("Oak", "Pine"), each = 5)
  result2 <- calculate_diversity(two_species)

  # 两个物种各占一半的Shannon指数应该为log(2)
  expected <- log(2)
  if (abs(result2$shannon - expected) > 1e-10) {
    stop("两个物种测试失败")
  }

  cat("所有测试通过！\n")
}

# 运行测试
test_diversity_calculation()
```

### 调试与错误处理

#### 错误信息解读与定位

```r
# 常见的R错误信息及解决方法

# 错误1：对象未找到
# Error: object 'x' not found
# 解决方法：检查变量名拼写，确保变量已赋值

# 错误2：函数参数不匹配
# Error in mean(x) : 参数不是数值也不是逻辑值：回传NA
# 解决方法：检查数据类型，确保输入是数值型

# 错误3：下标越界
# Error in x[5] : 下标出界
# 解决方法：检查向量长度，确保索引在有效范围内

# 实用的调试技巧
debug_calculation <- function(data) {
  # 使用browser()进行交互式调试
  browser()

  result <- complex_calculation(data)
  return(result)
}

# 使用tryCatch处理错误
safe_calculation <- function(data) {
  result <- tryCatch({
    # 尝试执行可能出错的操作
    calculate_diversity(data)
  }, error = function(e) {
    # 错误处理
    cat("计算失败:", e$message, "\n")
    return(NULL)
  }, warning = function(w) {
    # 警告处理
    cat("警告:", w$message, "\n")
    return(calculate_diversity(data))  # 继续执行
  })

  return(result)
}
```

## 模块三：R语言问题解决实践

### 数据处理基础

#### 数据导入与导出

```r
# 读取CSV文件
forest_data <- read.csv("data/forest_survey.csv")

# 读取Excel文件
library(readxl)
forest_data <- read_excel("data/forest_survey.xlsx")

# 保存处理后的数据
write.csv(cleaned_data, "output/cleaned_forest_data.csv", row.names = FALSE)

# 使用tidyverse更优雅的数据处理
library(tidyverse)

forest_data <- read_csv("data/forest_survey.csv") %>%
  mutate(dbh_category = case_when(
    dbh < 10 ~ "sapling",
    dbh < 30 ~ "medium",
    TRUE ~ "large"
  ))
```

#### 数据清洗与预处理

```r
# 数据质量检查函数
check_data_quality <- function(data) {
  cat("数据基本信息:\n")
  cat("行数:", nrow(data), "\n")
  cat("列数:", ncol(data), "\n")
  cat("缺失值数量:\n")
  print(colSums(is.na(data)))

  # 检查数值列的统计信息
  numeric_cols <- sapply(data, is.numeric)
  if (any(numeric_cols)) {
    cat("数值列统计信息:\n")
    print(summary(data[, numeric_cols]))
  }
}

# 数据清洗函数
clean_forest_data <- function(data) {
  cleaned <- data %>%
    # 去除完全空白的行
    filter(!is.na(species) | !is.na(dbh) | !is.na(height)) %>%

    # 处理缺失值
    mutate(
      dbh = ifelse(is.na(dbh), median(dbh, na.rm = TRUE), dbh),
      height = ifelse(is.na(height), median(height, na.rm = TRUE), height)
    ) %>%

    # 去除异常值（DBH为负值或极大值）
    filter(dbh > 0 & dbh < 300) %>%

    # 统一物种名称格式
    mutate(species = str_trim(tolower(species)))

  return(cleaned)
}
```

### 统计分析应用

#### 描述性统计分析

```r
# 生态学数据的描述性统计
descriptive_stats <- function(data) {
  stats <- list()

  # 数值变量的统计
  if ("dbh" %in% names(data)) {
    stats$dbh <- list(
      mean = mean(data$dbh, na.rm = TRUE),
      sd = sd(data$dbh, na.rm = TRUE),
      min = min(data$dbh, na.rm = TRUE),
      max = max(data$dbh, na.rm = TRUE),
      median = median(data$dbh, na.rm = TRUE)
    )
  }

  # 分类变量的统计
  if ("species" %in% names(data)) {
    stats$species_richness <- length(unique(data$species))
    stats$species_counts <- table(data$species)
  }

  return(stats)
}

# 使用示例
stats <- descriptive_stats(forest_data)
print(stats)
```

#### 推论统计方法

```r
# t检验示例：比较两个样地的平均胸径
# 假设我们有两个样地的数据
plot1_dbh <- c(15.3, 18.7, 22.1, 19.4, 16.8)
plot2_dbh <- c(12.9, 14.2, 11.7, 13.5, 15.1)

# 执行t检验
t_test_result <- t.test(plot1_dbh, plot2_dbh)
print(t_test_result)

# 方差分析示例：比较多个样地的多样性
library(dplyr)
library(vegan)

# 计算每个样地的Shannon指数
sample_data <- forest_data %>%
  group_by(plot_id) %>%
  summarise(
    shannon = diversity(table(species), index = "shannon")
  )

# 假设我们有样地类型信息（如：原始林、次生林、人工林）
# 执行方差分析
# aov_result <- aov(shannon ~ forest_type, data = sample_data)
# summary(aov_result)
```

### 可视化编程

#### ggplot2图形语法

```r
library(ggplot2)
library(dplyr)

# 创建生态学数据可视化
# 1. 物种分布直方图
species_histogram <- forest_data %>%
  ggplot(aes(x = dbh, fill = species)) +
  geom_histogram(binwidth = 5, alpha = 0.7) +
  labs(title = "不同物种的胸径分布",
       x = "胸径 (cm)",
       y = "个体数") +
  theme_minimal()

print(species_histogram)

# 2. 样地多样性比较
plot_diversity <- sample_data %>%
  ggplot(aes(x = factor(plot_id), y = shannon)) +
  geom_col(fill = "steelblue", alpha = 0.8) +
  labs(title = "各样地Shannon多样性指数比较",
       x = "样地编号",
       y = "Shannon多样性指数") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

print(plot_diversity)

# 3. 散点图：胸径与树高的关系
scatter_plot <- forest_data %>%
  ggplot(aes(x = dbh, y = height, color = species)) +
  geom_point(alpha = 0.6, size = 2) +
  geom_smooth(method = "lm", se = FALSE) +
  labs(title = "胸径与树高的关系",
       x = "胸径 (cm)",
       y = "树高 (m)") +
  theme_minimal()

print(scatter_plot)
```

## 模块四：综合实践项目

### 项目一：森林生态系统数据分析管道

```r
# 完整的森林数据分析项目
analyze_forest_ecosystem <- function(data_file, output_dir = "output") {

  # 创建输出目录
  if (!dir.exists(output_dir)) {
    dir.create(output_dir)
  }

  # 1. 数据读取与验证
  cat("步骤1: 读取数据...\n")
  raw_data <- read_forest_data(data_file)

  # 2. 数据质量检查
  cat("步骤2: 检查数据质量...\n")
  check_data_quality(raw_data)

  # 3. 数据清洗
  cat("步骤3: 数据清洗...\n")
  clean_data <- clean_forest_data(raw_data)

  # 4. 多样性分析
  cat("步骤4: 计算多样性指数...\n")
  diversity_by_plot <- clean_data %>%
    group_by(plot_id) %>%
    summarise(
      species_richness = n_distinct(species),
      shannon_index = diversity(table(species), index = "shannon"),
      simpson_index = diversity(table(species), index = "simpson")
    )

  # 5. 统计分析
  cat("步骤5: 执行统计分析...\n")
  # 这里可以添加各种统计检验

  # 6. 生成报告
  cat("步骤6: 生成分析报告...\n")
  generate_forest_report(clean_data, diversity_by_plot, output_dir)

  cat("分析完成！结果保存在", output_dir, "目录中\n")

  return(list(
    clean_data = clean_data,
    diversity_results = diversity_by_plot
  ))
}

# 生成分析报告的函数
generate_forest_report <- function(data, diversity_results, output_dir) {

  # 创建HTML报告
  rmarkdown::render(
    input = "templates/forest_report.Rmd",
    output_file = file.path(output_dir, "forest_analysis_report.html"),
    params = list(
      data = data,
      diversity_results = diversity_results
    )
  )

  # 保存关键结果到CSV
  write.csv(diversity_results,
            file.path(output_dir, "diversity_results.csv"),
            row.names = FALSE)

  # 生成摘要统计
  summary_stats <- data.frame(
    total_plots = nrow(diversity_results),
    total_species = length(unique(data$species)),
    total_individuals = nrow(data),
    mean_richness = mean(diversity_results$species_richness),
    mean_shannon = mean(diversity_results$shannon_index)
  )

  write.csv(summary_stats,
            file.path(output_dir, "summary_statistics.csv"),
            row.names = FALSE)
}
```

### 项目二：交互式生态数据可视化仪表板

```r
# 使用Shiny创建交互式仪表板（概念代码）
# 实际使用时需要创建单独的app.R文件

library(shiny)
library(ggplot2)
library(dplyr)

# UI定义
ui <- fluidPage(
  titlePanel("森林生态系统数据分析仪表板"),

  sidebarLayout(
    sidebarPanel(
      selectInput("plot_select", "选择样地:",
                  choices = unique(forest_data$plot_id)),
      selectInput("variable_x", "X轴变量:",
                  choices = c("dbh", "height", "species")),
      selectInput("variable_y", "Y轴变量:",
                  choices = c("height", "dbh")),
      actionButton("update_plot", "更新图表")
    ),

    mainPanel(
      plotOutput("species_plot"),
      plotOutput("diversity_plot"),
      tableOutput("summary_table")
    )
  )
)

# 服务器逻辑
server <- function(input, output) {

  # 反应式数据筛选
  filtered_data <- reactive({
    forest_data %>%
      filter(plot_id == input$plot_select)
  })

  # 物种分布图
  output$species_plot <- renderPlot({
    data <- filtered_data()

    ggplot(data, aes_string(x = input$variable_x, y = input$variable_y)) +
      geom_point(aes(color = species), size = 3, alpha = 0.7) +
      labs(title = paste("样地", input$plot_select, "物种分布")) +
      theme_minimal()
  })

  # 多样性图表
  output$diversity_plot <- renderPlot({
    # 计算并绘制多样性指数
    # ...
  })

  # 摘要表格
  output$summary_table <- renderTable({
    data <- filtered_data()

    data %>%
      summarise(
        `物种数` = n_distinct(species),
        `个体数` = n(),
        `平均胸径` = mean(dbh),
        `平均树高` = mean(height)
      )
  })
}

# 运行应用
# shinyApp(ui = ui, server = server)
```

## 总结

本章介绍了AI时代的统计编程基础，重点培养了三个核心能力：

1. **高阶思维与问题解决能力** - LLM难以替代的架构设计能力
2. **与LLM协同工作的能力** - 新时代的核心协作技能
3. **R语言问题解决实践** - 生态学数据分析的具体应用

通过模块化的学习路径和实际项目实践，学生将掌握现代编程思维，能够利用AI工具高效解决生态学研究中的数据分析问题。这种"解决方案设计师 + AI指令员 + 质量保证官"的角色定位，正是AI时代生态学研究者需要具备的核心竞争力。

在后续章节中，我们将深入探讨更专业的生态统计方法，但本章建立的编程思维框架将成为学习所有高级方法的基础。