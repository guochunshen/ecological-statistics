# 第07章 实验设计

## 实验设计基础概念

### 生态学背景

实验设计是生态学研究的核心环节，它决定了我们能否从数据中得出有效的科学结论。在森林生态学研究中，我们常常面临以下问题：氮沉降如何影响森林生产力？不同树种对干旱胁迫的响应有何差异？林下植被多样性如何影响树木生长？这些问题的回答都需要精心设计的实验。

良好的实验设计能够：
- **控制混杂因素**：排除其他变量的干扰，专注于研究因子
- **提高统计功效**：用最少的样本量检测到真实的效应
- **确保结果可靠性**：使研究结果具有可重复性和普遍性
- **优化资源配置**：在有限的经费和时间下获得最大信息量

例如，在研究施肥对树木生长的影响时，如果不考虑土壤养分背景的差异，可能会得出错误的结论。通过合理的实验设计，我们可以确保观察到的生长差异确实是由施肥引起的，而非其他环境因子的差异。

### 演示数据

让我们创建一个森林施肥实验的演示数据集，来展示不同实验设计的效果：

```r
# 森林施肥实验设计演示数据
set.seed(789)

# 实验设计参数
n_blocks <- 6        # 区组数
n_treatments <- 4    # 处理数：对照、低氮、中氮、高氮
n_plots <- 24        # 总样地数

# 创建实验设计矩阵
treatments <- c("Control", "Low_N", "Medium_N", "High_N")
experiment_design <- data.frame(
  Block = rep(1:n_blocks, each = n_treatments),
  Plot_ID = 1:n_plots,
  Treatment = rep(treatments, times = n_blocks)
)

# 添加环境协变量（土壤养分背景）
experiment_design$Soil_pH <- rnorm(n_plots, mean = 6.5, sd = 0.3)
experiment_design$Soil_N <- rnorm(n_plots, mean = 2.1, sd = 0.4)

# 模拟树木生长响应（考虑处理效应和环境因子）
# 真实处理效应：高氮 > 中氮 > 低氮 > 对照
treatment_effects <- c(Control = 0, Low_N = 0.8, Medium_N = 1.5, High_N = 2.2)

# 生成生长数据
experiment_design$Growth <- with(experiment_design, {
  # 基础生长 + 处理效应 + 环境效应 + 随机误差
  10 + treatment_effects[Treatment] + 
  0.5 * (Soil_pH - 6.5) + 
  1.2 * (Soil_N - 2.1) + 
  rnorm(n_plots, mean = 0, sd = 0.8)
})

# 显示实验设计
print("森林施肥实验设计：")
print(head(experiment_design, 8))

# 按处理组汇总
library(dplyr)
summary_stats <- experiment_design %>%
  group_by(Treatment) %>%
  summarise(
    n = n(),
    mean_growth = round(mean(Growth), 2),
    sd_growth = round(sd(Growth), 2)
  )
print("各处理组生长情况：")
print(summary_stats)
```

---

## 实验设计类型详解

### 操纵性实验 vs 自然实验

在生态学研究中，我们根据对实验条件的控制程度，将实验分为操纵性实验和自然实验两大类。

#### 操纵性实验（Manipulative Experiments）

操纵性实验是研究者主动控制实验条件，人为设置处理水平的实验设计。这类实验的最大优势是能够建立因果关系。

**特点**：
- **主动干预**：研究者直接操控研究变量
- **控制混杂因素**：通过随机化控制其他变量
- **因果关系明确**：可以明确得出X导致Y的结论
- **可重复性强**：实验条件可以精确复制

**森林生态学实例**：
在一个森林施肥实验中，我们设置4个氮添加水平（对照、低、中、高），每个处理在6个区组中重复，共24个样地。通过控制施肥量，我们可以准确评估氮添加对树木生长的影响。

#### 自然实验（Natural Experiments）

自然实验是利用自然发生的环境梯度或干扰事件作为"处理"的实验设计。虽然控制程度较低，但更接近自然状态。

**特点**：
- **利用自然变异**：依赖自然环境的变化
- **大尺度研究**：可以研究更大时空尺度的问题
- **生态现实性高**：结果更贴近自然状态
- **混杂因素较多**：需要仔细控制协变量

**森林生态学实例**：
研究火山喷发后不同年代的森林演替序列，或者沿着海拔梯度研究温度变化对森林结构的影响。

### 横断面实验 vs 轨迹实验

根据时间维度，实验设计可分为横断面和轨迹两种类型。

#### 横断面实验（Snapshot Experiments）

横断面实验在单一时间点采样，比较不同处理或条件下的响应差异。

**优点**：
- 实施简单，成本较低
- 可以快速获得结果
- 适合初步探索性研究

**缺点**：
- 无法观察动态过程
- 可能错过关键时间点
- 难以区分短期响应和长期适应

#### 轨迹实验（Trajectory Experiments）

轨迹实验通过多次采样，追踪生态系统随时间的变化过程。

**优点**：
- 可以观察动态变化过程
- 能够区分不同阶段响应
- 更接近真实生态过程

**缺点**：
- 需要长期投入
- 成本较高
- 可能受到其他干扰因素影响

### 持续性实验 vs 脉冲性实验

根据处理施加的方式，实验可分为持续性和脉冲性两种。

#### 持续性实验（Press Experiments）

持续性实验是指处理在整个实验期间持续施加，模拟长期环境变化。

**适用场景**：
- 模拟长期气候变化（如持续升温）
- 研究慢性污染效应
- 评估长期管理措施效果

**森林生态学实例**：
连续5年每年施加氮肥，研究长期氮沉降对森林土壤微生物群落的影响。

#### 脉冲性实验（Pulse Experiments）

脉冲性实验是指处理在短时间内施加后停止，模拟突发性环境事件。

**适用场景**：
- 模拟极端天气事件（如干旱、洪水）
- 研究干扰后的恢复过程
- 评估短期管理措施效果

**森林生态学实例**：
模拟一次极端干旱事件，研究森林在干旱期和恢复期的不同响应。

### R代码演示：不同类型实验的数据模拟

```r
# 模拟不同类型实验的数据
set.seed(123)

# 1. 操纵性实验数据
manipulative_data <- data.frame(
  Treatment = rep(c("Control", "Low_N", "High_N"), each = 10),
  Growth = c(rnorm(10, 10, 1), rnorm(10, 12, 1), rnorm(10, 15, 1))
)

# 2. 自然实验数据（沿海拔梯度）
natural_data <- data.frame(
  Elevation = seq(500, 2500, by = 100),
  Temperature = 20 - 0.006 * seq(500, 2500, by = 100),
  Species_Richness = round(50 - 0.01 * seq(500, 2500, by = 100) + rnorm(21, 0, 2))
)

# 3. 轨迹实验数据（5年跟踪）
trajectory_data <- expand.grid(
  Year = 2019:2023,
  Treatment = c("Control", "Fertilized")
)
trajectory_data$Biomass <- 100 + 
  (trajectory_data$Year - 2019) * 5 * (trajectory_data$Treatment == "Fertilized") +
  rnorm(nrow(trajectory_data), 0, 3)

# 4. 持续性 vs 脉冲性实验
# 持续性处理
press_data <- data.frame(
  Time = 1:12,
  Type = "Press",
  Response = 10 + 2 * (1:12) + rnorm(12, 0, 1)
)

# 脉冲性处理
pulse_data <- data.frame(
  Time = 1:12,
  Type = "Pulse",
  Response = c(rep(10, 3), rep(15, 3), rep(12, 6)) + rnorm(12, 0, 1)
)

# 可视化比较
par(mfrow = c(2, 2))

# 操纵性 vs 自然实验
plot(1:3, tapply(manipulative_data$Growth, manipulative_data$Treatment, mean),
     type = "b", xlab = "处理", ylab = "生长量", main = "操纵性实验")

plot(natural_data$Elevation, natural_data$Species_Richness,
     type = "b", xlab = "海拔(m)", ylab = "物种丰富度", main = "自然实验")

# 轨迹实验
plot(trajectory_data$Year, trajectory_data$Biomass,
     type = "b", col = as.numeric(trajectory_data$Treatment),
     xlab = "年份", ylab = "生物量", main = "轨迹实验")
legend("topleft", c("对照", "施肥"), col = 1:2, lty = 1)

# 持续性 vs 脉冲性
combined_data <- rbind(press_data, pulse_data)
plot(combined_data$Time, combined_data$Response, type = "n",
     xlab = "时间", ylab = "响应值", main = "持续性 vs 脉冲性")
lines(1:12, press_data$Response, type = "b", col = "blue")
lines(1:12, pulse_data$Response, type = "b", col = "red")
legend("topleft", c("持续性", "脉冲性"), col = c("blue", "red"), lty = 1)

par(mfrow = c(1, 1))
```

---

## 经典控制实验设计方法

### 正交设计 (Orthogonal Design)

正交设计是一种高效的多因子实验设计方法，通过精心选择的实验点组合，能够用较少的实验次数获得全面的信息。

#### 正交设计原理

正交设计的核心思想是让各因子的不同水平在所有组合中均匀分布，确保每个因子的效应估计相互独立。

```r
# 正交设计实现
library(DoE.base)

# 创建正交表
orthogonal_design <- oa.design(nfactors = 3, nlevels = 3, 
                              factor.names = list(
                                Temperature = c("Low", "Medium", "High"),
                                Moisture = c("Dry", "Medium", "Wet"),
                                Light = c("Low", "Medium", "High")
                              ))

print("3因子3水平正交设计：")
print(orthogonal_design)

# 正交设计分析
orthogonal_analysis <- function(design, responses) {
  # 计算各因子主效应
  main_effects <- data.frame()
  for(factor in names(design)) {
    if(factor != "response") {
      effect <- tapply(responses, design[[factor]], mean)
      main_effects <- rbind(main_effects, data.frame(
        Factor = factor,
        Level = names(effect),
        Mean_Response = effect
      ))
    }
  }
  return(main_effects)
}

# 使用示例
responses <- c(12.3, 15.6, 14.2, 18.9, 16.7, 20.1, 22.4, 19.8, 24.6)
results <- orthogonal_analysis(orthogonal_design, responses)
print("正交设计分析结果：")
print(results)
```

#### 正交设计优势

- **高效率**：用最少的实验次数获得最大信息
- **无偏估计**：各因子效应估计相互独立
- **易于分析**：方差分析结构清晰
- **适用性广**：适用于多因子多水平实验

### 响应曲面设计 (Response Surface Design)

响应曲面设计用于研究因子与响应之间的非线性关系，特别适用于优化实验。

#### 中心复合设计 (Central Composite Design)

```r
# 中心复合设计
library(rsm)

# 创建CCD设计
ccd_design <- ccd(2, n0 = 4, alpha = "rotatable", 
                 coding = list(x1 ~ (Temperature - 25)/5, 
                              x2 ~ (Moisture - 50)/10))

print("中心复合设计：")
print(ccd_design)

# 响应曲面分析
rsm_analysis <- function(design, responses) {
  # 拟合二次模型
  model <- rsm(responses ~ SO(x1, x2), data = design)
  
  # 寻找最优条件
  optimum <- steepest(model)
  
  return(list(model = summary(model), optimum = optimum))
}

# 使用示例
ccd_responses <- c(45, 52, 48, 55, 60, 58, 62, 65, 68, 72, 70, 75)
rsm_results <- rsm_analysis(ccd_design, ccd_responses)
print("响应曲面分析结果：")
print(rsm_results)
```

### 因子设计 (Factorial Design)

因子设计系统地研究多个因子的主效应和交互效应。

#### 完全因子设计

```r
# 完全因子设计
full_factorial <- function(factors) {
  design <- expand.grid(factors)
  design$Run_Order <- sample(1:nrow(design))
  return(design[order(design$Run_Order), ])
}

# 2×3×2因子设计
example_factors <- list(
  Nitrogen = c("Low", "Medium", "High"),
  Phosphorus = c("Low", "High"),
  Water = c("Normal", "Drought")
)

factorial_design <- full_factorial(example_factors)
print("完全因子设计：")
print(factorial_design)

# 因子设计分析
factorial_analysis <- function(design, responses) {
  # 三因素方差分析
  model <- aov(responses ~ Nitrogen * Phosphorus * Water, data = design)
  
  # 效应大小计算
  effects <- model.tables(model, type = "effects")
  
  return(list(anova = summary(model), effects = effects))
}

# 使用示例
factorial_responses <- rnorm(nrow(factorial_design), 100, 15)
factorial_results <- factorial_analysis(factorial_design, factorial_responses)
print("因子设计分析结果：")
print(factorial_results$anova)
```

### 拉丁方设计 (Latin Square Design)

拉丁方设计用于控制两个方向的变异来源。

```r
# 拉丁方设计
latin_square_design <- function(n) {
  # 创建n×n拉丁方
  square <- matrix(0, n, n)
  for(i in 1:n) {
    square[i, ] <- sample(1:n)
  }
  
  design <- data.frame(
    Row = rep(1:n, each = n),
    Column = rep(1:n, times = n),
    Treatment = as.vector(square)
  )
  
  return(design)
}

# 4×4拉丁方设计
latin_design <- latin_square_design(4)
print("拉丁方设计：")
print(latin_design)

# 拉丁方分析
latin_analysis <- function(design, responses) {
  model <- aov(responses ~ factor(Row) + factor(Column) + factor(Treatment), 
               data = design)
  return(summary(model))
}

# 使用示例
latin_responses <- rnorm(nrow(latin_design), 50, 8)
latin_results <- latin_analysis(latin_design, latin_responses)
print("拉丁方分析结果：")
print(latin_results)
```

### 希腊拉丁方设计 (Graeco-Latin Square Design)

希腊拉丁方设计可同时控制三个变异来源。

```r
# 希腊拉丁方设计
graeco_latin_design <- function(n) {
  # 创建两个正交拉丁方
  latin1 <- latin_square_design(n)$Treatment
  latin2 <- sample(1:n)
  
  design <- data.frame(
    Row = rep(1:n, each = n),
    Column = rep(1:n, times = n),
    Treatment1 = latin1,
    Treatment2 = rep(latin2, each = n)
  )
  
  return(design)
}

# 4×4希腊拉丁方设计
graeco_design <- graeco_latin_design(4)
print("希腊拉丁方设计：")
print(graeco_design)
```

### 裂区设计 (Split-Plot Design)

裂区设计适用于处理因子施加难度不同的情况。

```r
# 裂区设计
split_plot_design <- function(whole_plot_factors, sub_plot_factors, reps) {
  design <- expand.grid(
    Replicate = 1:reps,
    Whole_Plot = whole_plot_factors,
    Sub_Plot = sub_plot_factors
  )
  
  # 随机化
  design$Whole_Plot_Order <- unlist(tapply(design$Whole_Plot, 
                                         design$Replicate, 
                                         function(x) sample(x)))
  
  return(design)
}

# 裂区设计示例
whole_factors <- c("A", "B", "C")  # 难改变的处理
sub_factors <- c("X", "Y", "Z")    # 易改变的处理

split_design <- split_plot_design(whole_factors, sub_factors, 4)
print("裂区设计：")
print(head(split_design, 12))

# 裂区设计分析
split_plot_analysis <- function(design, responses) {
  library(lme4)
  
  model <- lmer(responses ~ Whole_Plot * Sub_Plot + (1|Replicate/Whole_Plot), 
                data = design)
  
  return(summary(model))
}
```

### 不完全区组设计 (Incomplete Block Design)

当区组容量小于处理数时使用不完全区组设计。

```r
# 不完全区组设计
incomplete_block_design <- function(treatments, block_size, n_blocks) {
  library(agricolae)
  
  design <- design.bib(treatments, n_blocks, block_size)
  
  return(design$book)
}

# 示例：6个处理，区组容量3，8个区组
ibd_design <- incomplete_block_design(6, 3, 8)
print("不完全区组设计：")
print(ibd_design)
```

## 实验设计核心原则

### 研究目的与研究问题

明确的研究目的是实验设计的起点。在森林生态学研究中，我们需要将宽泛的科学问题转化为具体、可检验的研究假设。

**好的研究问题特征：**
- **具体明确**：能够精确定义研究变量
- **可检验**：可以通过数据验证或证伪
- **生态意义**：对森林生态系统管理有实际价值
- **可行性**：在现有资源条件下可实施

**示例转换：**
- 宽泛问题："气候变化如何影响森林？"
- 具体问题："在未来50年内，温度升高2°C将如何改变亚热带常绿阔叶林的树种组成？"

### 重复与独立性

#### 重复的重要性

重复是统计推断的基础，它使我们能够估计自然变异并检验处理效应。

**重复层次：**
- **实验重复**：不同实验单元的重复
- **采样重复**：同一实验单元内的多次测量
- **时间重复**：不同时间点的重复观测

**森林生态学实例：**
在研究施肥对树木生长的影响时：
- 实验重复：6个区组 × 4个处理 = 24个独立样地
- 采样重复：每个样地内测量5棵代表性树木
- 时间重复：每年生长季末测量一次，连续3年

#### 独立性确保

独立性要求每个实验单元提供独立的信息，避免伪重复。

**常见独立性违反：**
- **空间自相关**：相邻样地间的相互影响
- **时间自相关**：连续测量的依赖性
- **遗传相关**：克隆植物或近缘个体

**解决方案：**
```r
# 检查空间自相关
library(spdep)
coords <- experiment_design[, c("Block", "Plot_ID")]
dist_matrix <- dist(coords)
moran.test(experiment_design$Growth, nb2listw(dnearneigh(coords, 0, 2)))

# 设计最小间距
min_distance <- 50  # 样地间最小距离50米
```

### 混杂因素控制

混杂因素是指与研究因子同时影响响应变量的其他变量，需要通过各种设计策略进行控制。

#### 常见混杂因素类型

**环境混杂：**
- 土壤养分水平差异
- 地形坡度变化
- 微气候差异

**生物混杂：**
- 初始植物大小差异
- 物种组成差异
- 年龄结构差异

#### 控制策略

**1. 随机化设计**
通过随机分配处理到实验单元，平衡已知和未知混杂因素。

```r
# 完全随机设计
set.seed(456)
n_plots <- 24
treatments <- rep(c("Control", "Low_N", "Medium_N", "High_N"), each = 6)
random_design <- data.frame(
  Plot_ID = 1:n_plots,
  Treatment = sample(treatments)
)
```

**2. 区组设计**
将相似的实验单元组成区组，在区组内随机分配处理。

```r
# 随机区组设计
set.seed(789)
n_blocks <- 6
block_design <- expand.grid(
  Block = 1:n_blocks,
  Treatment = c("Control", "Low_N", "Medium_N", "High_N")
)
# 在每个区组内随机排列处理
block_design$Plot_ID <- unlist(tapply(block_design$Treatment, 
                                         block_design$Block, 
                                         function(x) sample(x)))
```

**3. 协变量控制**
测量并统计控制重要的环境变量。

```r
# 使用协方差分析控制土壤因子
library(lmtest)
model1 <- lm(Growth ~ Treatment, data = experiment_design)
model2 <- lm(Growth ~ Treatment + Soil_N + Soil_pH, data = experiment_design)
lrtest(model1, model2)  # 检验土壤因子的显著性
```

### 随机化设计

随机化是实验设计的核心原则，它确保处理分配的公平性，平衡已知和未知混杂因素。

#### 随机化类型

**完全随机化：**
适用于实验单元相对均匀的情况。

```r
# 完全随机化设计
complete_random <- function(treatments, n_replicates) {
  design <- data.frame(
    Plot = 1:(length(treatments) * n_replicates),
    Treatment = rep(treatments, each = n_replicates)
  )
  design$Treatment <- sample(design$Treatment)
  return(design)
}

# 使用示例
random_layout <- complete_random(c("A", "B", "C", "D"), 6)
```

**分层随机化：**
适用于存在明显环境梯度的情况。

```r
# 分层随机化设计
stratified_random <- function(treatments, strata, n_per_stratum) {
  design <- data.frame()
  for(stratum in unique(strata)) {
    stratum_design <- data.frame(
      Stratum = stratum,
      Plot = 1:n_per_stratum,
      Treatment = sample(rep(treatments, length.out = n_per_stratum))
    )
    design <- rbind(design, stratum_design)
  }
  return(design)
}

# 使用示例
elevation_strata <- c(rep("Low", 12), rep("High", 12))
stratified_design <- stratified_random(c("Control", "Treatment"), elevation_strata, 4)
```

**随机化检验：**
验证随机化是否成功平衡了混杂因素。

```r
# 随机化检验
randomization_check <- function(design, covariates) {
  results <- data.frame()
  for(covar in names(covariates)) {
    test <- tapply(covariates[[covar]], design$Treatment, function(x) {
      c(mean = mean(x), sd = sd(x))
    })
    results <- rbind(results, data.frame(
      Variable = covar,
      Treatment = names(test),
      Mean = sapply(test, "[", "mean"),
      SD = sapply(test, "[", "sd")
    ))
  }
  return(results)
}

# 检验示例
covariates <- experiment_design[, c("Soil_pH", "Soil_N")]
balance_check <- randomization_check(experiment_design, covariates)
print("随机化平衡检验：")
print(balance_check)
```

---

## 野外实验设计实践

### 样地选择与设置

#### 样地选择原则

**代表性原则：**
样地应能代表研究区域的典型生态系统特征。

**均质性原则：**
在实验开始前，尽量确保处理组间的初始条件相似。

**实用性原则：**
考虑交通可达性、安全性和长期维护的可行性。

#### 样地设置步骤

**步骤1：预调查**
```r
# 预调查数据分析
pre_survey <- data.frame(
  Site_ID = 1:30,
  Elevation = runif(30, 800, 1200),
  Slope = runif(30, 5, 25),
  Soil_pH = rnorm(30, 6.5, 0.4),
  Canopy_cover = runif(30, 60, 90),
  Species_richness = rpois(30, 25)
)

# 环境梯度分析
library(vegan)
env_pca <- rda(pre_survey[, -1], scale = TRUE)
plot(env_pca, main = "环境变量主成分分析")
```

**步骤2：样地划分**
```r
# 样地设置参数
plot_size <- 20  # 20m × 20m样地
buffer_zone <- 10  # 缓冲带10米

# 创建样地布局
setup_plots <- function(corners, size) {
  plots <- data.frame()
  for(i in 1:nrow(corners)) {
    plot_coords <- data.frame(
      Plot_ID = i,
      Corner_NW_N = corners[i, "N"] + size/2,
      Corner_NW_E = corners[i, "E"] - size/2,
      Corner_SE_N = corners[i, "N"] - size/2,
      Corner_SE_E = corners[i, "E"] + size/2
    )
    plots <- rbind(plots, plot_coords)
  }
  return(plots)
}
```

### 采样策略设计

#### 采样方法选择

**系统采样：**
按照固定间隔设置采样点，适用于环境梯度明显的区域。

**随机采样：**
在样地内随机选择采样点，适用于相对均匀的环境。

**分层采样：**
根据微环境特征分层后采样，确保覆盖不同微生境。

#### 采样强度计算

```r
# 样本量计算函数
sample_size_calc <- function(effect_size, power = 0.8, alpha = 0.05, 
                               sd_within = 1, k_groups = 2) {
  # 基于功效分析的样本量计算
  library(pwr)
  
  if(k_groups == 2) {
    # t检验样本量
    n_per_group <- pwr.t.test(d = effect_size/sd_within, power = power, 
                              sig.level = alpha)$n
  } else {
    # 方差分析样本量
    n_per_group <- pwr.anova.test(k = k_groups, f = effect_size/sd_within, 
                               power = power, sig.level = alpha)$n
  }
  
  return(ceiling(n_per_group))
}

# 使用示例
n_needed <- sample_size_calc(effect_size = 2, sd_within = 1.5, k_groups = 4)
cat("每组需要", n_needed, "个重复\n")
```

### 环境因子控制

#### 环境因子监测

**微气候监测：**
```r
# 微气候传感器设置
microclimate_setup <- data.frame(
  Sensor_type = c("Temperature", "Humidity", "Light", "Soil_moisture"),
  Location = "每个样地中心",
  Interval = "每小时记录",
  Duration = "整个实验期"
)
```

**土壤因子标准化：**
```r
# 土壤因子标准化处理
soil_standardization <- function(plot_data) {
  # 土壤pH调整
  plot_data$Soil_pH_adj <- ifelse(plot_data$Soil_pH < 6.0, 
                                   "添加石灰", "保持原状")
  
  # 土壤养分平衡
  plot_data$Fertilizer_rate <- case_when(
    plot_data$Soil_N < 1.5 ~ 150,    # kg/ha
    plot_data$Soil_N < 2.5 ~ 100,
    TRUE ~ 50
  )
  
  return(plot_data)
}
```

#### 生物因子控制

**初始植被控制：**
```r
# 植被清理和标准化
vegetation_control <- function(plot_data) {
  # 移除异常植物
  plot_data$Removal_needed <- plot_data$Canopy_cover > 95 | plot_data$Canopy_cover < 40
  
  # 补植标准
  plot_data$Planting_needed <- plot_data$Tree_density < 0.8 * mean(plot_data$Tree_density)
  
  return(plot_data)
}
```

**竞争控制：**
```r
# 竞争强度评估
competition_index <- function(neighbor_data) {
  # 计算竞争指数
  neighbor_data$CI <- with(neighbor_data, {
    sum(DBH_neighbor / Distance^2)
  })
  return(neighbor_data)
}
```

---

## 统计实现与R代码演示

### 实验设计模拟

#### 设计矩阵生成

```r
# 创建复杂实验设计矩阵
create_experiment_design <- function(factors, replicates, blocks = NULL) {
  
  # 生成交互设计
  design <- expand.grid(factors)
  design$Replicate <- rep(1:replicates, each = nrow(design))
  
  if(!is.null(blocks)) {
    design$Block <- rep(1:blocks, each = nrow(design)/blocks)
  }
  
  # 随机化处理顺序
  design$Order <- sample(1:nrow(design))
  
  return(design[order(design$Order), ])
}

# 使用示例：2×2×2因子设计
factors <- list(
  Fertilizer = c("None", "High"),
  Water = c("Normal", "Drought"),
  Species = c("Pine", "Oak")
)

complex_design <- create_experiment_design(factors, replicates = 4, blocks = 2)
print("复杂实验设计：")
print(head(complex_design, 12))
```

#### 效应模拟

```r
# 模拟不同效应类型
simulate_effects <- function(design, effect_type = "additive") {
  
  # 基础响应
  response <- 10 + rnorm(nrow(design), 0, 1)
  
  # 添加处理效应
  if(effect_type == "additive") {
    # 加性效应
    response <- response + 
      ifelse(design$Fertilizer == "High", 3, 0) +
      ifelse(design$Water == "Drought", -2, 0) +
      ifelse(design$Species == "Oak", 1, 0)
  } else if(effect_type == "interactive") {
    # 交互效应
    response <- response + 
      ifelse(design$Fertilizer == "High", 3, 0) +
      ifelse(design$Water == "Drought", -2, 0) +
      ifelse(design$Species == "Oak", 1, 0) +
      ifelse(design$Fertilizer == "High" & design$Water == "Drought", 4, 0)
  }
  
  design$Response <- response
  return(design)
}

# 模拟不同效应
additive_data <- simulate_effects(complex_design, "additive")
interactive_data <- simulate_effects(complex_design, "interactive")
```

### 功效分析

#### 基础功效分析

```r
# 单因素方差分析功效分析
power_anova <- function(group_means, group_sds, n_per_group) {
  
  library(pwr)
  
  # 计算效应量
  grand_mean <- mean(group_means)
  between_var <- sum((group_means - grand_mean)^2) / length(group_means)
  within_var <- mean(group_sds^2)
  
  f <- sqrt(between_var / within_var)
  
  # 功效分析
  power_result <- pwr.anova.test(k = length(group_means), 
                               f = f, 
                               n = n_per_group)
  
  return(power_result)
}

# 使用示例
group_means <- c(10, 12, 15, 18)
group_sds <- c(2, 2.5, 2, 2.2)
power_result <- power_anova(group_means, group_sds, 6)
print(power_result)
```

#### 复杂设计功效分析

```r
# 两因素设计功效分析
library(simr)

# 创建线性混合效应模型
library(lme4)
model <- lmer(Response ~ Fertilizer * Water + (1|Block), 
               data = additive_data)

# 功效分析
power_sim <- powerSim(model, nsim = 100)
print(power_sim)

# 样本量优化
plot_power <- function(model, effect_sizes, n_range) {
  powers <- numeric(length(n_range))
  
  for(i in seq_along(n_range)) {
    new_data <- expand.grid(
      Fertilizer = unique(additive_data$Fertilizer),
      Water = unique(additive_data$Water),
      Block = unique(additive_data$Block)
    )
    new_data <- new_data[rep(1:nrow(new_data), each = n_range[i]), ]
    
    new_model <- lmer(Response ~ Fertilizer * Water + (1|Block), 
                      data = new_data)
    
    powers[i] <- powerSim(new_model, nsim = 50)$power
  }
  
  plot(n_range, powers, type = "b", 
       xlab = "每处理重复数", ylab = "统计功效")
  abline(h = 0.8, col = "red", lty = 2)
}

plot_power(model, seq(3, 10), seq(3, 10))
```

### 随机化检验

#### 随机化检验原理

随机化检验通过重排处理标签来评估观察到的效应是否显著大于随机期望。

```r
# 随机化检验函数
randomization_test <- function(data, response_var, treatment_var, 
                               n_perms = 1000) {
  
  observed_stat <- summary(lm(get(response_var) ~ get(treatment_var), 
                              data = data))$coefficients[2, 3]
  
  perm_stats <- numeric(n_perms)
  
  for(i in 1:n_perms) {
    perm_data <- data
    perm_data$Treatment_Perm <- sample(data[[treatment_var]])
    
    perm_stats[i] <- summary(lm(get(response_var) ~ Treatment_Perm, 
                                data = perm_data))$coefficients[2, 3]
  }
  
  p_value <- (sum(abs(perm_stats) >= abs(observed_stat)) + 1) / (n_perms + 1)
  
  return(list(
    observed = observed_stat,
    p_value = p_value,
    perm_stats = perm_stats
  ))
}

# 使用示例
test_result <- randomization_test(experiment_design, "Growth", "Treatment")
cat("随机化检验p值：", test_result$p_value, "\n")
```

#### 高级随机化检验

```r
# 考虑空间结构的随机化检验
spatial_randomization <- function(data, response_var, treatment_var, 
                                  coords, n_perms = 1000) {
  
  library(spdep)
  
  # 创建空间权重矩阵
  coords_df <- data.frame(x = coords[,1], y = coords[,2])
  dists <- dist(coords_df)
  nb <- dnearneigh(coords_df, 0, 50)  # 50米内邻居
  
  # 空间约束的随机化
  observed_stat <- summary(lm(get(response_var) ~ get(treatment_var), 
                              data = data))$coefficients[2, 3]
  
  # 实施空间约束的随机化
  # 这里简化为随机化
  perm_stats <- numeric(n_perms)
  
  for(i in 1:n_perms) {
    perm_data <- data
    perm_data$Treatment_Perm <- sample(data[[treatment_var]])
    
    perm_stats[i] <- summary(lm(get(response_var) ~ Treatment_Perm, 
                                data = perm_data))$coefficients[2, 3]
  }
  
  p_value <- (sum(abs(perm_stats) >= abs(observed_stat)) + 1) / (n_perms + 1)
  
  return(list(
    observed = observed_stat,
    p_value = p_value,
    perm_stats = perm_stats
  ))
}
```

---

## 综合案例研究

### 森林生物多样性实验

#### 研究背景

森林生物多样性如何影响生态系统功能是生态学研究的核心问题之一。我们将设计一个综合性的生物多样性实验，研究树种丰富度对森林生产力和稳定性的影响。

#### 实验设计

**研究问题：**
树种丰富度如何影响森林初级生产力和年际稳定性？

**实验设计：**
- **因子设计**：3个树种丰富度水平（1、3、6个树种）
- **树种选择**：从12个本地树种中随机选择组合
- **重复设置**：每个丰富度水平8个重复，共24个样地
- **样地大小**：30m × 30m，足够容纳成熟林冠层

#### 数据模拟与分析

```r
# 生物多样性实验数据模拟
set.seed(2024)

# 实验参数
n_plots <- 24
richness_levels <- c(1, 3, 6)
species_pool <- paste0("SP", 1:12)

# 创建实验设计
biodiversity_design <- data.frame(
  Plot_ID = 1:n_plots,
  Richness = rep(richness_levels, each = 8)
)

# 随机分配树种组合
assign_species <- function(richness, species_pool) {
  sample(species_pool, richness)
}

biodiversity_design$Species <- sapply(biodiversity_design$Richness, 
                                    function(r) paste(assign_species(r, species_pool), 
                                                     collapse = ","))

# 模拟生产力响应（多样性效应）
biodiversity_design$Productivity <- with(biodiversity_design, {
  # 基础生产力 + 多样性效应 + 取样效应 + 互补效应
  100 + 
    5 * Richness +  # 取样效应
    3 * log(Richness) +  # 互补效应
    rnorm(n_plots, 0, 8)  # 随机误差
})

# 年际稳定性（变异系数倒数）
biodiversity_design$Stability <- with(biodiversity_design, {
  1 / (0.1 + 0.02 * (6 - Richness) + rnorm(n_plots, 0, 0.05))
})

# 可视化结果
par(mfrow = c(1, 2))

# 生产力 vs 丰富度
plot(biodiversity_design$Richness, biodiversity_design$Productivity,
     xlab = "树种丰富度", ylab = "生产力 (t/ha/年)",
     pch = 19, col = "darkgreen", main = "多样性-生产力关系")
lines(1:6, 100 + 5 * (1:6) + 3 * log(1:6), col = "red", lwd = 2)

# 稳定性 vs 丰富度
plot(biodiversity_design$Richness, biodiversity_design$Stability,
     xlab = "树种丰富度", ylab = "稳定性 (1/CV)",
     pch = 19, col = "blue", main = "多样性-稳定性关系")
lines(1:6, 1 / (0.1 + 0.02 * (6 - (1:6))), col = "red", lwd = 2)

par(mfrow = c(1, 1))

# 统计分析
library(lme4)
diversity_model <- lm(Productivity ~ Richness, data = biodiversity_design)
summary(diversity_model)

# 检验非线性关系
nonlinear_model <- lm(Productivity ~ poly(Richness, 2), data = biodiversity_design)

# 模型比较
anova(diversity_model, nonlinear_model)
```

### 气候变化响应实验

#### 研究背景

气候变化正在改变森林生态系统的结构和功能。通过控制实验研究森林对温度升高和降水变化的响应，对于预测未来森林动态至关重要。

#### 实验设计

**研究问题：**
温度和降水变化如何影响亚热带森林的树木生长和水分利用效率？

**实验设置：**
- **温度处理**：对照、+2°C、+4°C
- **降水处理**：减少30%、对照、增加30%
- **因子组合**：3×3全因子设计
- **树种**：马尾松、杉木、樟树（代表不同功能类型）
- **重复**：每个处理组合5个重复
- **实验装置**：开顶式气候室（OTC）

#### 数据模拟与分析

```r
# 气候变化响应实验数据模拟
set.seed(2024)

# 实验参数
temperature_levels <- c("Control", "+2C", "+4C")
precipitation_levels <- c("-30%", "Control", "+30%")
species <- c("Pine", "Fir", "Camphor")

# 创建实验设计
climate_design <- expand.grid(
  Temperature = temperature_levels,
  Precipitation = precipitation_levels,
  Species = species
)
climate_design$Replicate <- rep(1:5, each = nrow(unique(climate_design[, 1:3])))

# 模拟响应变量
climate_design$Growth_Response <- with(climate_design, {
  # 基础生长率
  base_growth <- ifelse(Species == "Pine", 1.2,
                        ifelse(Species == "Fir", 1.0, 0.8))
  
  # 温度效应
  temp_effect <- ifelse(Temperature == "Control", 0,
                       ifelse(Temperature == "+2C", 0.1, -0.05))
  
  # 降水效应
  precip_effect <- ifelse(Precipitation == "Control", 0,
                         ifelse(Precipitation == "+30%", 0.15, -0.2))
  
  # 交互效应
  interaction_effect <- ifelse(Temperature == "+4C" & Precipitation == "-30%", 
                               -0.3, 0)
  
  # 物种特异性响应
  species_effect <- case_when(
    Species == "Pine" ~ 0.1,
    Species == "Fir" ~ -0.05,
    Species == "Camphor" ~ 0.05
  )
  
  # 最终响应 + 随机误差
  base_growth + temp_effect + precip_effect + 
    interaction_effect + species_effect + rnorm(nrow(climate_design), 0, 0.1)
})

# 水分利用效率
climate_design$WUE <- with(climate_design, {
  2.5 + 0.3 * as.numeric(Temperature == "+2C") -
    0.5 * as.numeric(Precipitation == "-30%") +
    rnorm(nrow(climate_design), 0, 0.2)
})

# 高级分析
library(lmerTest)

# 三因素方差分析
climate_model <- lmer(Growth_Response ~ Temperature * Precipitation * Species + 
                         (1|Replicate), data = climate_design)
summary(climate_model)

# 交互效应可视化
library(ggplot2)
ggplot(climate_design, aes(x = Temperature, y = Growth_Response, color = Species)) +
  geom_boxplot() +
  facet_wrap(~Precipitation) +
  labs(title = "气候变化对树木生长的影响",
       x = "温度处理", y = "相对生长率") +
  theme_minimal()

# 响应曲面分析
library(rsm)
rsm_model <- rsm(Growth_Response ~ FO(Temperature, Precipitation), 
                data = climate_design[climate_design$Species == "Pine",])
summary(rsm_model)
```

### 实验设计评估与优化

#### 设计效率评估

```r
# 设计效率指标计算
design_efficiency <- function(design) {
  # D-最优性
  X <- model.matrix(~ Temperature * Precipitation * Species, data = design)
  D_efficiency <- det(t(X) %*% X)^(1/nrow(X))
  
  # A-最优性
  A_efficiency <- 1 / sum(diag(solve(t(X) %*% X)))
  
  # 条件数
  XX <- t(X) %*% X
  eigen_vals <- eigen(XX)$values
  condition_number <- sqrt(max(eigen_vals) / min(eigen_vals))
  
  return(list(
    D_efficiency = D_efficiency,
    A_efficiency = A_efficiency,
    Condition_number = condition_number
  ))
}

# 评估当前设计
efficiency_metrics <- design_efficiency(climate_design)
print("设计效率指标：")
print(efficiency_metrics)
```

#### 敏感性分析

```r
# 参数敏感性分析
sensitivity_analysis <- function(base_params, param_ranges) {
  
  results <- data.frame()
  
  for(param_name in names(param_ranges)) {
    param_values <- seq(param_ranges[[param_name]][1], 
                        param_ranges[[param_name]][2], 
                        length.out = 20)
    
    for(value in param_values) {
      # 修改参数
      new_params <- base_params
      new_params[param_name] <- value
      
      # 重新计算功效
      power <- calculate_power(new_params)
      
      results <- rbind(results, data.frame(
        Parameter = param_name,
        Value = value,
        Power = power
      ))
    }
  }
  
  return(results)
}

# 使用示例
base_params <- list(effect_size = 0.5, n_per_group = 5, sd = 0.1)
param_ranges <- list(
  effect_size = c(0.1, 1.0),
  n_per_group = c(3, 10),
  sd = c(0.05, 0.2)
)

sens_results <- sensitivity_analysis(base_params, param_ranges)

# 可视化
library(ggplot2)
ggplot(sens_results, aes(x = Value, y = Power, color = Parameter)) +
  geom_line() +
  facet_wrap(~Parameter, scales = "free_x") +
  geom_hline(yintercept = 0.8, linetype = "dashed") +
  labs(title = "实验设计敏感性分析",
       y = "统计功效") +
  theme_minimal()
```

---

## 课后练习

### 练习1：森林碳汇实验设计

某研究团队想研究不同森林管理措施对碳汇功能的影响。设计一个包含以下要素的实验：
- **处理**：对照、间伐、施肥、间伐+施肥
- **响应变量**：树干生长量、叶片碳含量、土壤碳储量
- **环境因子**：海拔、坡向、土壤类型
- **时间尺度**：5年跟踪

要求：
1. 设计实验方案（包括重复数和空间布局）
2. 创建模拟数据集
3. 进行功效分析
4. 编写R代码实现随机化设计

### 练习2：极端天气事件模拟

设计一个模拟极端干旱和极端降水事件的实验：
- **处理**：对照、干旱、极端降水、干旱+降水恢复
- **树种**：选择3个不同耐旱性的树种
- **测量指标**：树木水势、叶片气孔导度、生长量

要求：
1. 设计脉冲性实验方案
2. 模拟响应数据（考虑物种特异性响应）
3. 分析交互效应
4. 可视化结果

### 练习3：城市森林实验设计

在城市环境中研究绿化树种选择对微气候和空气质量的影响：
- **研究地点**：城市公园、街道绿化带、居民小区
- **树种**：常绿树、落叶树、针叶树、阔叶树
- **响应变量**：温度、湿度、PM2.5浓度、居民满意度

要求：
1. 设计嵌套实验（考虑不同空间尺度）
2. 处理空间自相关
3. 控制城市环境混杂因素
4. 评估设计效率

### 练习参考代码框架

```r
# 练习1框架
forest_carbon_experiment <- function() {
  # 实验设计
  treatments <- c("Control", "Thinning", "Fertilizer", "Both")
  
  # 创建设计矩阵
  design <- create_experiment_design(
    list(Management = treatments),
    replicates = 8,
    blocks = 4
  )
  
  # 模拟响应
  design$Carbon_Sequestration <- with(design, {
    50 +  # 基础碳汇
      ifelse(Management == "Thinning", 10, 0) +
      ifelse(Management == "Fertilizer", 15, 0) +
      ifelse(Management == "Both", 25, 0) +
      rnorm(nrow(design), 0, 5)
  })
  
  return(design)
}

# 练习2框架
drought_experiment <- function() {
  # 时间序列设计
  time_points <- 0:12  # 月
  species <- c("Drought_tolerant", "Mesic", "Drought_sensitive")
  
  # 创建设计
  drought_design <- expand.grid(
    Time = time_points,
    Species = species,
    Treatment = c("Control", "Drought", "Extreme_rain", "Recovery")
  )
  
  # 模拟响应（考虑恢复过程）
  drought_design$Water_Potential <- with(drought_design, {
    base_wp <- ifelse(Species == "Drought_tolerant", -1,
                     ifelse(Species == "Mesic", -1.5, -2))
    
    drought_effect <- ifelse(Treatment == "Drought", -1.5,
                           ifelse(Treatment == "Extreme_rain", 0.5, 0))
    
    recovery_effect <- ifelse(Treatment == "Recovery", 
                             -1.5 * exp(-Time/3), 0)
    
    base_wp + drought_effect + recovery_effect + rnorm(nrow(drought_design), 0, 0.2)
  })
  
  return(drought_design)
}

# 练习3框架
urban_forest_experiment <- function() {
  # 嵌套设计
  sites <- c("Park", "Street", "Residential")
  tree_types <- c("Evergreen", "Deciduous", "Conifer", "Broadleaf")
  
  # 创建嵌套设计
  urban_design <- expand.grid(
    Site_Type = sites,
    Tree_Type = tree_types
  )
  urban_design$Subsite <- rep(1:3, each = nrow(urban_design))
  urban_design$Replicate <- rep(1:5, each = nrow(unique(urban_design[, 1:3])))
  
  # 模拟响应（考虑城市环境效应）
  urban_design$Temperature_Reduction <- with(urban_design, {
    base_effect <- ifelse(Tree_Type %in% c("Broadleaf", "Deciduous"), 2, 1.5)
    site_effect <- case_when(
      Site_Type == "Park" ~ 0.5,
      Site_Type == "Street" ~ 0,
      Site_Type == "Residential" ~ 0.3
    )
    
    base_effect + site_effect + rnorm(nrow(urban_design), 0, 0.3)
  })
  
  return(urban_design)
}
```
