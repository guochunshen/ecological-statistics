
## 第9课：编程基础与逻辑控制

### 生态学背景
在群落生态学研究中，经常需要根据不同条件对物种进行分类处理，或者对大量样地数据进行批量处理。这需要用到编程中的条件判断和循环结构，让R能够自动化完成重复性工作。

### 演示数据
```r
# 某自然保护区不同海拔的物种调查数据
sites_data <- data.frame(
  site_id = paste0("S", 1:10),
  elevation = c(1200, 1450, 1800, 2100, 2350, 1650, 1900, 2200, 1750, 2050),
  species_count = c(45, 52, 38, 28, 22, 48, 35, 25, 42, 30),
  dominant_species = c("栎树", "栎树", "云杉", "冷杉", "高山杜鹃", "栎树", "云杉", "冷杉", "云杉", "冷杉")
)
```

### 课堂演示过程

#### 1. 条件判断基础
```r
# 创建示例数据
sites_data <- data.frame(
  site_id = paste0("S", 1:10),
  elevation = c(1200, 1450, 1800, 2100, 2350, 1650, 1900, 2200, 1750, 2050),
  species_count = c(45, 52, 38, 28, 22, 48, 35, 25, 42, 30),
  dominant_species = c("栎树", "栎树", "云杉", "冷杉", "高山杜鹃", "栎树", "云杉", "冷杉", "云杉", "冷杉")
)

# 简单的if语句
elevation_threshold <- 2000
if (sites_data$elevation[1] > elevation_threshold) {
  print("高海拔样地")
} else {
  print("低海拔样地")
}

# if-else判断所有样地
for (i in 1:nrow(sites_data)) {
  if (sites_data$elevation[i] > 2000) {
    print(paste(sites_data$site_id[i], "是高海拔样地"))
  } else {
    print(paste(sites_data$site_id[i], "是低海拔样地"))
  }
}
```

#### 2. 向量化条件判断
```r
# 使用ifelse()函数进行向量化判断
sites_data$elevation_zone <- ifelse(sites_data$elevation > 2000, "高海拔", "低海拔")
print(sites_data[, c("site_id", "elevation", "elevation_zone")])

# 多层条件判断
sites_data$vegetation_type <- ifelse(sites_data$elevation < 1500, "阔叶林",
                                    ifelse(sites_data$elevation < 2000, "混交林", "针叶林"))
print(sites_data[, c("site_id", "elevation", "vegetation_type")])
```

#### 3. for循环处理
```r
# 计算每个样地的多样性指数类别
diversity_categories <- character(nrow(sites_data))

for (i in 1:nrow(sites_data)) {
  species_num <- sites_data$species_count[i]
  if (species_num >= 40) {
    diversity_categories[i] <- "高多样性"
  } else if (species_num >= 30) {
    diversity_categories[i] <- "中等多样性"  
  } else {
    diversity_categories[i] <- "低多样性"
  }
}

sites_data$diversity_category <- diversity_categories
print(sites_data[, c("site_id", "species_count", "diversity_category")])
```

#### 4. 自定义函数编写
```r
# 编写海拔带判断函数
classify_elevation_zone <- function(elevation) {
  if (elevation < 1500) {
    return("低山带")
  } else if (elevation < 2000) {
    return("中山带")
  } else {
    return("高山带")
  }
}

# 测试函数
classify_elevation_zone(1800)
classify_elevation_zone(2200)

# 批量应用函数
sites_data$elevation_belt <- sapply(sites_data$elevation, classify_elevation_zone)
print(sites_data[, c("site_id", "elevation", "elevation_belt")])
```

#### 5. 复杂条件处理
```r
# 编写综合评估函数
assess_conservation_value <- function(elevation, species_count, dominant_sp) {
  score <- 0
  
  # 海拔因子
  if (elevation > 2000) {
    score <- score + 2
  } else if (elevation > 1500) {
    score <- score + 1
  }
  
  # 物种多样性因子
  if (species_count > 40) {
    score <- score + 2
  } else if (species_count > 30) {
    score <- score + 1
  }
  
  # 优势种稀有性因子
  rare_species <- c("高山杜鹃", "冷杉")
  if (dominant_sp %in% rare_species) {
    score <- score + 1
  }
  
  # 返回保护价值等级
  if (score >= 4) {
    return("极高价值")
  } else if (score >= 3) {
    return("高价值")
  } else if (score >= 2) {
    return("中等价值")
  } else {
    return("一般价值")
  }
}

# 应用综合评估
sites_data$conservation_value <- mapply(assess_conservation_value, 
                                       sites_data$elevation,
                                       sites_data$species_count,
                                       sites_data$dominant_species)

print(sites_data[, c("site_id", "conservation_value")])
```

### R语言知识点详解

#### 1. 条件判断结构

##### `if` 语句
- **语法**：`if (条件) { 执行代码 }`
- **条件**：必须是逻辑值（TRUE/FALSE）
- **执行规则**：条件为TRUE时执行大括号内的代码
- **注意事项**：条件必须是长度为1的逻辑向量

##### `if-else` 语句
- **语法**：
  ```r
  if (条件) {
    # 条件为TRUE时执行
  } else {
    # 条件为FALSE时执行
  }
  ```
- **多重条件**：`else if`可以链式连接
- **最佳实践**：始终使用大括号，即使只有一行代码

##### `ifelse()` 函数（向量化）
- **语法**：`ifelse(test, yes, no)`
- **优势**：可以处理向量，一次性判断多个元素
- **参数**：
  - `test`：逻辑向量条件
  - `yes`：条件为TRUE时返回的值
  - `no`：条件为FALSE时返回的值
- **嵌套使用**：可以嵌套实现多重条件判断

#### 2. 循环结构

##### `for` 循环
- **语法**：`for (变量 in 序列) { 循环体 }`
- **常见用法**：
  ```r
  # 按索引循环
  for (i in 1:10) { }
  
  # 按元素循环
  for (item in vector) { }
  
  # 按名称循环
  for (name in names(list)) { }
  ```
- **循环控制**：
  - `break`：跳出循环
  - `next`：跳过当前迭代

##### 其他循环类型
- **`while` 循环**：`while (条件) { 循环体 }`
- **`repeat` 循环**：`repeat { 循环体; if(条件) break }`

#### 3. 函数定义

##### 基本函数语法
- **语法**：
  ```r
  函数名 <- function(参数1, 参数2 = 默认值) {
    # 函数体
    return(返回值)
  }
  ```
- **参数**：
  - 必需参数：调用时必须提供
  - 可选参数：有默认值，可省略
- **返回值**：
  - 显式返回：使用`return()`
  - 隐式返回：函数最后一个表达式的值

##### 函数设计原则
- **单一职责**：一个函数只做一件事
- **参数验证**：检查输入参数的有效性
- **错误处理**：使用`stop()`、`warning()`处理异常
- **文档化**：添加注释说明函数用途和参数

#### 4. 高级应用函数

##### `sapply()` - 简化的apply
- **作用**：对向量或列表的每个元素应用函数
- **语法**：`sapply(X, FUN, ...)`
- **返回值**：简化后的向量或矩阵
- **与`lapply()`的区别**：
  - `lapply()`总是返回列表
  - `sapply()`尝试简化结果

##### `mapply()` - 多变量apply
- **作用**：同时对多个向量应用函数
- **语法**：`mapply(FUN, ..., MoreArgs = NULL)`
- **应用场景**：函数需要多个参数时使用
- **示例**：`mapply(function(x, y) x + y, vector1, vector2)`

#### 5. 逻辑运算符

##### 基本逻辑运算符
- **`==`**：等于
- **`!=`**：不等于
- **`>`**、`<`**、`>=`**、`<=`**：比较运算符
- **`&`**：与（向量化）
- **`|`**：或（向量化）
- **`!`**：非
- **`&&`**、`||`**：短路逻辑运算符（只判断第一个元素）

##### 成员测试
- **`%in%`**：检查元素是否在向量中
- **`is.na()`**：检查缺失值
- **`is.null()`**：检查空值

#### 6. 编程最佳实践

##### 代码组织
- **缩进**：使用一致的缩进（建议2或4个空格）
- **命名**：使用有意义的变量名和函数名
- **注释**：解释复杂逻辑和算法思路
- **模块化**：将复杂任务分解为简单函数

##### 性能考虑
- **向量化**：优先使用向量化操作而非循环
- **预分配**：循环前预分配存储空间
- **避免增长**：不要在循环中动态增长向量

##### 调试技巧
- **`print()`**：在关键位置输出变量值
- **`browser()`**：设置断点进行交互式调试
- **`traceback()`**：查看错误调用堆栈
- **分步测试**：逐步测试函数的各个部分

### 课后练习

**题目**：某湿地鸟类监测数据包含以下信息：
```r
bird_monitoring <- data.frame(
  site = c("A1", "A2", "B1", "B2", "C1", "C2"),
  water_depth = c(15, 25, 45, 35, 65, 55),  # 水深(cm)
  bird_abundance = c(8, 12, 20, 16, 5, 8),   # 鸟类丰度
  season = c("春季", "春季", "夏季", "夏季", "秋季", "秋季")
)
```

请完成（使用if-else、循环、函数等编程内容，结合之前学过的数据处理方法）：
1. 使用`ifelse()`函数，根据水深将栖息地分类（<30cm浅水区，30-50cm中等深度，>50cm深水区）
2. 编写函数`classify_habitat_quality()`，综合水深和鸟类丰度评估栖息地质量
3. 使用`for`循环，计算每个季节的平均鸟类丰度
4. 创建一个新列，标记高丰度样地（丰度>15为高丰度，使用ifelse()）
5. 编写函数处理整个数据集，输出每个样地的综合评估报告
6. 使用`apply`族函数重做第3题（比较循环和向量化方法的差异）
