
# 概率与统计基础

## 概率

### 什么是概率 

#### 概率的基本概念
概率是描述随机事件发生可能性的数值度量，取值范围在0到1之间。

```r
# 概率的基本性质演示
# 概率值范围：0 ≤ P(A) ≤ 1
prob_values <- seq(0, 1, 0.1)
print("概率值范围:")
print(prob_values)

# 必然事件的概率为1，不可能事件的概率为0
certain_event <- 1
impossible_event <- 0
print(paste("必然事件概率:", certain_event))
print(paste("不可能事件概率:", impossible_event))
```

#### 概率的三种主要定义

##### 1. 经典概率（等可能概率）
假设所有基本事件等可能发生，概率 = 有利事件数 / 总事件数

```r
# 经典概率示例：掷骰子
# 掷出6点的概率
total_outcomes <- 6
favorable_outcomes <- 1
prob_six <- favorable_outcomes / total_outcomes
print(paste("掷出6点的概率:", round(prob_six, 3)))

# 生态学应用：随机选择一棵树为特定物种的概率
total_trees <- 100
species_a_trees <- 25
prob_species_a <- species_a_trees / total_trees
print(paste("随机选择一棵树为物种A的概率:", prob_species_a))
```

##### 2. 频率概率（经验概率）
基于大量重复试验中事件发生的相对频率

```r
# 频率概率示例：种子萌发率
set.seed(123)
n_trials <- 1000
germination_prob <- 0.75

# 模拟种子萌发试验
germination_results <- rbinom(n_trials, 1, germination_prob)
empirical_prob <- mean(germination_results)

print(paste("理论萌发概率:", germination_prob))
print(paste("经验萌发概率:", round(empirical_prob, 3)))
print(paste("试验次数:", n_trials))

# 展示随着试验次数增加，频率趋近于概率
cumulative_means <- cumsum(germination_results) / (1:n_trials)
plot(1:n_trials, cumulative_means, type = "l", 
     xlab = "试验次数", ylab = "萌发频率",
     main = "频率趋近于概率")
abline(h = germination_prob, col = "red", lty = 2)
```

##### 3. 主观概率（贝叶斯概率）
基于个人信念或专家知识对事件可能性的主观判断

```r
# 主观概率示例：专家对森林火灾风险的评估
expert_judgment <- c(0.7, 0.8, 0.6, 0.9, 0.75)  # 五位专家的评估
subjective_prob <- mean(expert_judgment)

print("专家对森林火灾风险的主观概率评估:")
print(expert_judgment)
print(paste("平均主观概率:", round(subjective_prob, 3)))

# 主观概率在生态学决策中的应用
decision_threshold <- 0.7
if (subjective_prob > decision_threshold) {
  print("采取防火措施 - 风险较高")
} else {
  print("维持常规监测 - 风险适中")
}
```

#### 生态学中的概率应用

```r
# 生态学概率应用案例
# 1. 物种出现概率
set.seed(456)
species_presence <- rbinom(50, 1, 0.4)  # 40%的出现概率
presence_prob <- mean(species_presence)
print(paste("物种出现概率:", round(presence_prob, 3)))

# 2. 动物存活概率
survival_data <- c(0.85, 0.92, 0.78, 0.88, 0.83)  # 不同年份的存活率
avg_survival <- mean(survival_data)
print(paste("平均存活概率:", round(avg_survival, 3)))

# 3. 栖息地适宜性概率
habitat_suitability <- runif(20, 0.3, 0.9)  # 随机生成适宜性概率
print("栖息地适宜性概率示例:")
print(round(habitat_suitability, 3))
```

### 概率的度量 

#### 概率的基本性质
概率度量遵循三个基本公理：
1. 非负性：P(A) ≥ 0
2. 规范性：P(Ω) = 1（样本空间概率为1）
3. 可加性：互斥事件的并集概率等于各事件概率之和

```r
# 概率公理演示
# 1. 非负性
prob_values <- c(0, 0.25, 0.5, 0.75, 1)
print("概率值（非负性）:")
print(prob_values)

# 2. 规范性
sample_space_prob <- 1
print(paste("样本空间概率:", sample_space_prob))

# 3. 可加性（互斥事件）
# 假设三个互斥的栖息地类型
prob_forest <- 0.6
prob_grassland <- 0.3
prob_wetland <- 0.1

# 选择森林或草地的概率
prob_forest_or_grassland <- prob_forest + prob_grassland
print(paste("森林或草地概率:", prob_forest_or_grassland))

# 验证总和为1
total_prob <- prob_forest + prob_grassland + prob_wetland
print(paste("总概率:", total_prob))
```

#### 概率的计算方法

##### 古典概率计算
```r
# 古典概率计算示例
# 从10个物种中随机选择3个，包含特定稀有物种的概率
total_species <- 10
rare_species <- 1
select_count <- 3

# 计算组合数
library(combinat)
total_combinations <- choose(total_species, select_count)
favorable_combinations <- choose(total_species - rare_species, select_count - 1)

prob_include_rare <- favorable_combinations / total_combinations
print(paste("包含稀有物种的概率:", round(prob_include_rare, 4)))
print(paste("总组合数:", total_combinations))
print(paste("有利组合数:", favorable_combinations))
```

##### 频率概率计算
```r
# 频率概率计算示例
# 基于野外调查数据计算物种出现频率
set.seed(789)
survey_data <- matrix(rbinom(200, 1, 0.35), nrow = 20, ncol = 10)  # 20个样方，10个物种
colnames(survey_data) <- paste("Species", LETTERS[1:10])

# 计算每个物种的出现频率
species_frequencies <- colMeans(survey_data)
print("物种出现频率:")
print(round(species_frequencies, 3))

# 可视化物种出现频率
barplot(species_frequencies, 
        main = "物种出现频率", 
        xlab = "物种", ylab = "出现概率",
        col = "lightblue", ylim = c(0, 1))
abline(h = mean(species_frequencies), col = "red", lty = 2)
```

##### 条件概率计算
```r
# 条件概率示例
# 给定栖息地类型条件下，物种出现的概率
set.seed(321)

# 创建模拟数据
habitat_types <- c("Forest", "Grassland", "Wetland")
n_samples <- 100

# 生成栖息地类型和物种出现数据
habitat <- sample(habitat_types, n_samples, replace = TRUE, prob = c(0.6, 0.3, 0.1))
species_present <- numeric(n_samples)

# 不同栖息地中物种出现概率不同
for (i in 1:n_samples) {
  if (habitat[i] == "Forest") {
    species_present[i] <- rbinom(1, 1, 0.8)
  } else if (habitat[i] == "Grassland") {
    species_present[i] <- rbinom(1, 1, 0.4)
  } else {
    species_present[i] <- rbinom(1, 1, 0.2)
  }
}

# 计算条件概率
prob_forest_given_present <- sum(habitat == "Forest" & species_present == 1) / sum(species_present == 1)
prob_present_given_forest <- sum(habitat == "Forest" & species_present == 1) / sum(habitat == "Forest")

print(paste("P(森林 | 物种出现):", round(prob_forest_given_present, 3)))
print(paste("P(物种出现 | 森林):", round(prob_present_given_forest, 3)))
```

#### 生态学中的概率度量应用

```r
# 生态学概率度量案例
# 1. 种群生存概率分析
set.seed(555)
years <- 10
population_size <- 1000
survival_prob <- 0.85

# 模拟种群年存活数量
annual_survivors <- rbinom(years, population_size, survival_prob)
survival_rates <- annual_survivors / population_size

print("年存活概率:")
print(round(survival_rates, 3))
print(paste("平均存活概率:", round(mean(survival_rates), 3)))

# 2. 物种共存概率
# 计算两个物种在样方中共同出现的概率
set.seed(666)
n_quadrats <- 50
species1_prob <- 0.6
species2_prob <- 0.4

# 模拟物种出现数据
species1 <- rbinom(n_quadrats, 1, species1_prob)
species2 <- rbinom(n_quadrats, 1, species2_prob)

# 计算共存概率
cooccurrence <- sum(species1 == 1 & species2 == 1) / n_quadrats
prob_cooccurrence <- mean(species1) * mean(species2)  # 如果独立

print(paste("实际共存概率:", round(cooccurrence, 3)))
print(paste("独立假设下的期望共存概率:", round(prob_cooccurrence, 3)))

# 3. 风险评估概率
# 计算极端气候事件的发生概率
climate_events <- c(0.02, 0.05, 0.01, 0.03, 0.02)  # 不同严重级别事件的概率
risk_score <- sum(climate_events * c(1, 3, 5, 2, 4))  # 加权风险评分

print("气候事件概率分布:")
print(round(climate_events, 3))
print(paste("综合风险评分:", round(risk_score, 3)))
```

### 概率定义中的问题 

#### 经典概率定义的局限性

##### 等可能性假设问题
经典概率基于所有基本事件等可能的假设，但这在生态学中往往不成立。

```r
# 等可能性假设问题演示
# 假设森林中不同树种的出现概率不等
set.seed(111)
species <- c("Oak", "Pine", "Birch", "Maple", "Other")
actual_probs <- c(0.4, 0.3, 0.15, 0.1, 0.05)  # 实际概率
classical_probs <- rep(0.2, 5)  # 经典概率假设

# 比较实际概率与等可能假设
comparison <- data.frame(
  Species = species,
  Actual_Probability = actual_probs,
  Classical_Assumption = classical_probs,
  Difference = actual_probs - classical_probs
)

print("等可能性假设 vs 实际概率:")
print(comparison)

# 可视化比较
barplot(t(cbind(actual_probs, classical_probs)), 
        beside = TRUE, 
        names.arg = species,
        main = "等可能性假设 vs 实际概率",
        xlab = "物种", ylab = "概率",
        col = c("lightblue", "lightgreen"))
legend("topright", legend = c("实际概率", "等可能假设"), 
       fill = c("lightblue", "lightgreen"))
```

##### 有限总体问题
经典概率要求明确知道总体大小，但生态学中总体往往无限或未知。

```r
# 有限总体问题示例
# 估计森林中濒危物种的数量
set.seed(222)

# 实际濒危物种数量（未知）
true_rare_species <- 15

# 调查发现的物种数量（抽样偏差）
observed_species <- 8
survey_effort <- 50  # 调查努力程度

detection_prob <- observed_species / survey_effort
estimated_total <- observed_species / detection_prob

print(paste("实际濒危物种数量:", true_rare_species))
print(paste("观测到的物种数量:", observed_species))
print(paste("检测概率:", round(detection_prob, 3)))
print(paste("估计的物种总数:", round(estimated_total, 1)))
print(paste("估计误差:", round(abs(estimated_total - true_rare_species), 1)))
```

#### 频率概率定义的问题

##### 大数定律的实践限制
频率概率需要大量重复试验，但生态学调查往往样本量有限。

```r
# 大数定律实践限制演示
set.seed(333)
true_prob <- 0.35
sample_sizes <- c(10, 30, 100, 300, 1000)

# 不同样本量下的概率估计
estimates <- sapply(sample_sizes, function(n) {
  mean(rbinom(n, 1, true_prob))
})

# 计算估计误差
errors <- abs(estimates - true_prob)

results <- data.frame(
  Sample_Size = sample_sizes,
  Estimated_Probability = round(estimates, 3),
  Error = round(errors, 3)
)

print("不同样本量下的概率估计:")
print(results)

# 可视化样本量与估计误差的关系
plot(sample_sizes, errors, type = "b", 
     xlab = "样本量", ylab = "估计误差",
     main = "样本量对概率估计精度的影响",
     pch = 19, col = "blue")
abline(h = 0, col = "red", lty = 2)
```

##### 无法处理一次性事件
频率定义无法处理不可重复的独特生态事件。

```r
# 一次性事件问题示例
# 评估特定森林火灾事件的发生概率
set.seed(444)

# 历史火灾数据（有限的历史记录）
historical_fires <- c(0.01, 0.02, 0.015, 0.025, 0.03)  # 年发生概率

# 当前气候条件下的估计（主观调整）
current_risk <- mean(historical_fires) * 1.5  # 假设风险增加50%

print("历史火灾概率:")
print(round(historical_fires, 4))
print(paste("平均历史概率:", round(mean(historical_fires), 4)))
print(paste("调整后的当前风险:", round(current_risk, 4)))
print("注：基于频率的定义无法准确评估独特气候事件的风险")
```

#### 主观概率定义的问题

##### 主观偏见问题
主观概率容易受到个人偏见、经验局限性和认知偏差的影响。

```r
# 主观偏见问题演示
set.seed(555)

# 不同专家对同一生态风险的评估
experts <- c("Ecologist_A", "Ecologist_B", "Forest_Manager", "Local_Community")
risk_assessments <- list(
  c(0.7, 0.8, 0.6),  # 生态学家A的多次评估
  c(0.4, 0.5, 0.3),  # 生态学家B的评估
  c(0.9, 0.85, 0.95), # 森林管理者的评估
  c(0.2, 0.3, 0.25)   # 当地社区的评估
)

# 计算每个群体的平均评估
average_assessments <- sapply(risk_assessments, mean)
assessment_range <- sapply(risk_assessments, function(x) diff(range(x)))

bias_analysis <- data.frame(
  Group = experts,
  Average_Risk = round(average_assessments, 3),
  Assessment_Range = round(assessment_range, 3),
  Bias_Indicator = abs(average_assessments - mean(average_assessments))
)

print("不同群体的风险评估（显示主观偏见）:")
print(bias_analysis)

print(paste("评估差异范围:", round(diff(range(average_assessments)), 3)))
```

##### 缺乏客观验证
主观概率难以用客观数据进行验证和校准。

```r
# 主观概率验证问题
set.seed(666)

# 专家预测 vs 实际观测
n_predictions <- 20
expert_predictions <- runif(n_predictions, 0.3, 0.8)  # 专家预测
actual_outcomes <- rbinom(n_predictions, 1, 0.5)      # 实际二值结果

# 计算预测准确性
calibration_error <- mean(abs(expert_predictions - actual_outcomes))
brier_score <- mean((expert_predictions - actual_outcomes)^2)

print("专家预测验证:")
print(data.frame(
  Prediction = round(expert_predictions, 3),
  Outcome = actual_outcomes,
  Error = round(abs(expert_predictions - actual_outcomes), 3)
))

print(paste("校准误差:", round(calibration_error, 3)))
print(paste("Brier分数:", round(brier_score, 3)))
print("注：低分数表示更好的校准，但主观概率缺乏客观验证标准")
```

#### 生态学中的概率定义选择指南

```r
# 概率定义选择指南
probability_definitions <- data.frame(
  Definition = c("Classical", "Frequentist", "Subjective"),
  Strengths = c("简单直观", "基于数据", "处理不确定性"),
  Limitations = c("等可能假设", "需要大量数据", "主观偏见"),
  Ecology_Applications = c("简单随机抽样", "长期监测数据", "专家判断决策")
)

print("概率定义选择指南:")
print(probability_definitions)

# 根据数据类型选择概率定义
data_types <- c("等可能事件", "重复观测", "独特事件", "专家知识")
recommended_definitions <- c("Classical", "Frequentist", "Subjective", "Subjective")

selection_guide <- data.frame(
  Data_Type = data_types,
  Recommended_Definition = recommended_definitions
)

print("\n基于数据类型的概率定义选择:")
print(selection_guide)
```

### 概率的数学基础 

#### 概率公理体系

##### 科尔莫戈罗夫公理
现代概率论建立在三个基本公理之上：

```r
# 概率公理验证
# 公理1: 非负性 P(A) ≥ 0
prob_values <- c(0, 0.25, 0.5, 0.75, 1)
non_negative <- all(prob_values >= 0)
print(paste("公理1验证（非负性）:", non_negative))

# 公理2: 规范性 P(Ω) = 1
sample_space <- 1
normative <- sample_space == 1
print(paste("公理2验证（规范性）:", normative))

# 公理3: 可加性 互斥事件概率可加
# 假设三个互斥的生态事件
prob_A <- 0.3
prob_B <- 0.4
prob_C <- 0.3

# 验证互斥事件概率和
additive <- (prob_A + prob_B + prob_C) == 1
print(paste("公理3验证（可加性）:", additive))

# 公理体系完整性验证
axioms_valid <- non_negative && normative && additive
print(paste("概率公理体系完整性:", axioms_valid))
```

#### 集合论基础

##### 基本集合运算
```r
# 集合运算演示
# 定义生态事件集合
set.seed(777)

# 创建物种出现数据
species <- LETTERS[1:10]
n_samples <- 100

# 生成物种出现矩阵
occurrence_matrix <- matrix(rbinom(1000, 1, 0.4), nrow = n_samples, ncol = 10)
colnames(occurrence_matrix) <- species

# 定义事件：物种A出现
event_A <- occurrence_matrix[, "A"] == 1

# 定义事件：物种B出现  
event_B <- occurrence_matrix[, "B"] == 1

# 基本集合运算
union_AB <- event_A | event_B         # 并集：A或B出现
intersection_AB <- event_A & event_B   # 交集：A和B都出现
complement_A <- !event_A              # 补集：A不出现

difference_AB <- event_A & !event_B    # 差集：A出现但B不出现

# 计算概率
prob_union <- mean(union_AB)
prob_intersection <- mean(intersection_AB)
prob_complement <- mean(complement_A)
prob_difference <- mean(difference_AB)

print("集合运算概率结果:")
print(paste("P(A ∪ B):", round(prob_union, 3)))
print(paste("P(A ∩ B):", round(prob_intersection, 3)))
print(paste("P(Aᶜ):", round(prob_complement, 3)))
print(paste("P(A - B):", round(prob_difference, 3)))

# 验证包含-排除原理
inclusion_exclusion <- mean(event_A) + mean(event_B) - mean(intersection_AB)
print(paste("包含-排除原理验证 P(A) + P(B) - P(A∩B):", round(inclusion_exclusion, 3)))
print(paste("直接计算 P(A ∪ B):", round(prob_union, 3)))
```

##### 德摩根定律
```r
# 德摩根定律验证
# 定律1: (A ∪ B)ᶜ = Aᶜ ∩ Bᶜ
# 定律2: (A ∩ B)ᶜ = Aᶜ ∪ Bᶜ

de_morgan1 <- mean(!(event_A | event_B)) == mean(!event_A & !event_B)
de_morgan2 <- mean(!(event_A & event_B)) == mean(!event_A | !event_B)

print(paste("德摩根定律1验证:", de_morgan1))
print(paste("德摩根定律2验证:", de_morgan2))

# 实际数值验证
print(paste("P((A∪B)ᶜ):", round(mean(!(event_A | event_B)), 4)))
print(paste("P(Aᶜ∩Bᶜ):", round(mean(!event_A & !event_B), 4)))
print(paste("P((A∩B)ᶜ):", round(mean(!(event_A & event_B)), 4)))
print(paste("P(Aᶜ∪Bᶜ):", round(mean(!event_A | !event_B), 4)))
```

#### 条件概率与独立性

##### 条件概率计算
```r
# 条件概率详细计算
set.seed(888)

# 创建栖息地类型和物种出现数据
habitats <- c("Forest", "Grassland", "Wetland")
n_observations <- 200

habitat_data <- sample(habitats, n_observations, replace = TRUE, 
                       prob = c(0.6, 0.3, 0.1))

# 不同栖息地中物种出现概率
species_presence <- numeric(n_observations)
for (i in 1:n_observations) {
  if (habitat_data[i] == "Forest") {
    species_presence[i] <- rbinom(1, 1, 0.7)
  } else if (habitat_data[i] == "Grassland") {
    species_presence[i] <- rbinom(1, 1, 0.4)
  } else {
    species_presence[i] <- rbinom(1, 1, 0.2)
  }
}

# 计算条件概率
prob_forest <- mean(habitat_data == "Forest")
prob_species <- mean(species_presence == 1)
prob_species_given_forest <- mean(species_presence[habitat_data == "Forest"] == 1)
prob_forest_given_species <- mean(habitat_data[species_presence == 1] == "Forest")

# 验证条件概率公式
conditional_formula <- (prob_species_given_forest * prob_forest) / prob_species

print("条件概率计算结果:")
print(paste("P(森林):", round(prob_forest, 3)))
print(paste("P(物种出现):", round(prob_species, 3)))
print(paste("P(物种出现 | 森林):", round(prob_species_given_forest, 3)))
print(paste("P(森林 | 物种出现):", round(prob_forest_given_species, 3)))
print(paste("公式验证 [P(物种|森林)*P(森林)]/P(物种):", round(conditional_formula, 3)))
```

##### 独立性检验
```r
# 事件独立性检验
set.seed(999)

# 创建两个可能相关的事件
n_trials <- 1000

# 事件C: 降雨事件
rain_prob <- 0.3
rain_events <- rbinom(n_trials, 1, rain_prob)

# 事件D: 植物开花事件（与降雨相关）
flower_prob <- ifelse(rain_events == 1, 0.8, 0.2)
flower_events <- rbinom(n_trials, 1, flower_prob)

# 检验独立性
prob_rain <- mean(rain_events)
prob_flower <- mean(flower_events)
prob_rain_and_flower <- mean(rain_events & flower_events)

# 独立性条件: P(A∩B) = P(A)P(B)
independence_check <- abs(prob_rain_and_flower - (prob_rain * prob_flower)) < 0.05

print("事件独立性检验:")
print(paste("P(降雨):", round(prob_rain, 3)))
print(paste("P(开花):", round(prob_flower, 3)))
print(paste("P(降雨∩开花):", round(prob_rain_and_flower, 3)))
print(paste("P(降雨)P(开花):", round(prob_rain * prob_flower, 3)))
print(paste("是否独立:", !independence_check))
print(paste("差异:", round(abs(prob_rain_and_flower - prob_rain * prob_flower), 4)))

# 卡方独立性检验
contingency_table <- table(rain_events, flower_events)
chi_test <- chisq.test(contingency_table)

print("卡方独立性检验:")
print(chi_test)
print(paste("p值:", round(chi_test$p.value, 4)))
```

#### 全概率公式与贝叶斯基础

##### 全概率公式
```r
# 全概率公式应用
set.seed(1010)

# 定义不同的生态情景（划分样本空间）
scenarios <- c("Normal", "Drought", "Flood")
scenario_probs <- c(0.7, 0.2, 0.1)  # 情景概率

# 不同情景下物种灭绝的概率
extinction_probs <- c(0.1, 0.6, 0.3)  # 正常、干旱、洪水下的灭绝概率

# 使用全概率公式计算总体灭绝概率
total_extinction_prob <- sum(scenario_probs * extinction_probs)

# 模拟验证
n_simulations <- 10000
extinction_count <- 0

for (i in 1:n_simulations) {
  # 随机选择情景
  scenario <- sample(1:3, 1, prob = scenario_probs)
  # 根据情景决定是否灭绝
  if (rbinom(1, 1, extinction_probs[scenario]) == 1) {
    extinction_count <- extinction_count + 1
  }
}

empirical_prob <- extinction_count / n_simulations

print("全概率公式应用:")
print(paste("理论总体灭绝概率:", round(total_extinction_prob, 3)))
print(paste("经验总体灭绝概率:", round(empirical_prob, 3)))
print(paste("绝对误差:", round(abs(total_extinction_prob - empirical_prob), 4)))

# 显示各情景贡献
contribution_df <- data.frame(
  Scenario = scenarios,
  Scenario_Probability = scenario_probs,
  Extinction_Probability = extinction_probs,
  Contribution = scenario_probs * extinction_probs
)

print("各情景对总体灭绝概率的贡献:")
print(contribution_df)
```

##### 贝叶斯定理基础
```r
# 贝叶斯定理基础演示
set.seed(1111)

# 先验概率：疾病在种群中的 prevalence
prior_prob <- 0.05  # 5%的个体患病

# 检测准确性
sensitivity <- 0.95  # 真阳性率
specificity <- 0.90  # 真阴性率

# 计算边际概率: P(阳性)
marginal_positive <- prior_prob * sensitivity + (1 - prior_prob) * (1 - specificity)

# 使用贝叶斯定理计算后验概率: P(患病|阳性)
posterior_prob <- (sensitivity * prior_prob) / marginal_positive

print("贝叶斯定理基础演示（疾病检测）:")
print(paste("先验概率 P(患病):", prior_prob))
print(paste("检测灵敏度 P(阳性|患病):", sensitivity))
print(paste("检测特异度 P(阴性|健康):", specificity))
print(paste("边际概率 P(阳性):", round(marginal_positive, 4)))
print(paste("后验概率 P(患病|阳性):", round(posterior_prob, 4)))

# 可视化先验与后验概率
probs <- c(prior_prob, posterior_prob)
barplot(probs, 
        names.arg = c("先验概率", "后验概率"),
        main = "贝叶斯更新: 先验 vs 后验",
        ylab = "概率", ylim = c(0, 1),
        col = c("lightblue", "lightgreen"))
```

#### 概率的数学性质证明

```r
# 重要概率性质的数学验证
set.seed(1212)

# 性质1: P(Aᶜ) = 1 - P(A)
n <- 1000
event_A <- rbinom(n, 1, 0.6)
prob_A <- mean(event_A)
prob_complement <- mean(!event_A)

property1 <- abs(prob_complement - (1 - prob_A)) < 1e-10
print(paste("性质1验证 P(Aᶜ) = 1 - P(A):", property1))
print(paste("P(A):", round(prob_A, 3), "P(Aᶜ):", round(prob_complement, 3)))

# 性质2: 如果A ⊆ B, 则 P(A) ≤ P(B)
# 创建嵌套事件
event_B <- event_A | rbinom(n, 1, 0.2)  # B包含A和一些额外事件
prob_B <- mean(event_B)

property2 <- prob_A <= prob_B
print(paste("性质2验证 A ⊆ B ⇒ P(A) ≤ P(B):", property2))
print(paste("P(A):", round(prob_A, 3), "P(B):", round(prob_B, 3)))

# 性质3: P(A ∪ B) = P(A) + P(B) - P(A ∩ B)
event_C <- rbinom(n, 1, 0.4)
event_D <- rbinom(n, 1, 0.3)

prob_C <- mean(event_C)
prob_D <- mean(event_D)
prob_C_union_D <- mean(event_C | event_D)
prob_C_intersect_D <- mean(event_C & event_D)

property3 <- abs(prob_C_union_D - (prob_C + prob_D - prob_C_intersect_D)) < 1e-10
print(paste("性质3验证 P(A∪B) = P(A) + P(B) - P(A∩B):", property3))
print(paste("左边:", round(prob_C_union_D, 3), "右边:", 
            round(prob_C + prob_D - prob_C_intersect_D, 3)))

# 布尔不等式: P(∪A_i) ≤ ΣP(A_i)
events <- matrix(rbinom(5*n, 1, 0.2), nrow = n, ncol = 5)
union_prob <- mean(apply(events, 1, any))
sum_probs <- sum(colMeans(events))

bool_inequality <- union_prob <= sum_probs
print(paste("布尔不等式验证 P(∪A_i) ≤ ΣP(A_i):", bool_inequality))
print(paste("P(∪A_i):", round(union_prob, 3), "ΣP(A_i):", round(sum_probs, 3)))
```

### 贝叶斯定理 

#### 贝叶斯公式与推导

##### 基本贝叶斯公式
贝叶斯定理描述了如何根据新证据更新先验信念：
P(H|E) = [P(E|H) × P(H)] / P(E)

```r
# 基本贝叶斯公式实现
bayes_theorem <- function(prior, likelihood, evidence) {
  # P(H|E) = [P(E|H) * P(H)] / P(E)
  posterior <- (likelihood * prior) / evidence
  return(posterior)
}

# 生态学应用示例：物种检测
prior_prob <- 0.10       # 先验：物种存在的概率
likelihood_pos <- 0.95   # 似然：如果存在，检测到的概率
evidence_pos <- 0.15     # 证据：检测到信号的概率

posterior_prob <- bayes_theorem(prior_prob, likelihood_pos, evidence_pos)

print("贝叶斯定理基本应用:")
print(paste("先验概率 P(存在):", prior_prob))
print(paste("似然函数 P(检测|存在):", likelihood_pos))
print(paste("证据 P(检测):", evidence_pos))
print(paste("后验概率 P(存在|检测):", round(posterior_prob, 4)))

# 验证全概率公式
# P(检测) = P(检测|存在)P(存在) + P(检测|不存在)P(不存在)
likelihood_neg <- 0.05   # 如果不存在，错误检测的概率
evidence_calculated <- likelihood_pos * prior_prob + likelihood_neg * (1 - prior_prob)

print(paste("计算证据 P(检测):", round(evidence_calculated, 4)))
print(paste("与输入证据的差异:", round(abs(evidence_pos - evidence_calculated), 4)))
```

##### 贝叶斯更新过程
```r
# 贝叶斯更新过程演示
set.seed(1313)

# 初始先验：对森林健康的信念
prior_belief <- c(0.3, 0.5, 0.2)  # 差、中、好的概率
names(prior_belief) <- c("Poor", "Fair", "Good")

print("初始先验信念:")
print(round(prior_belief, 3))

# 收集证据：树木死亡率观测
# 不同健康状态下的死亡率似然
mortality_likelihood <- c(0.8, 0.3, 0.1)  # 差、中、好状态下的死亡率
names(mortality_likelihood) <- c("Poor", "Fair", "Good")

# 观测到的死亡率证据
observed_mortality <- 0.4

# 计算证据概率（标准化常数）
evidence_prob <- sum(prior_belief * mortality_likelihood)

# 贝叶斯更新计算后验
posterior_belief <- (prior_belief * mortality_likelihood) / evidence_prob

print("贝叶斯更新结果:")
print("先验信念:")
print(round(prior_belief, 3))
print("似然函数 P(死亡率|健康状态):")
print(round(mortality_likelihood, 3))
print("证据概率 P(死亡率):", round(evidence_prob, 3))
print("后验信念 P(健康状态|死亡率):")
print(round(posterior_belief, 3))

# 可视化先验与后验
library(ggplot2)
belief_df <- data.frame(
  Health_State = rep(names(prior_belief), 2),
  Probability = c(prior_belief, posterior_belief),
  Type = rep(c("Prior", "Posterior"), each = 3)
)

ggplot(belief_df, aes(x = Health_State, y = Probability, fill = Type)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "贝叶斯更新: 先验信念与后验信念",
       x = "健康状态", y = "概率") +
  theme_minimal()
```

#### 生态学中的贝叶斯应用

##### 物种分布模型
```r
# 贝叶斯物种分布模型
set.seed(1414)

# 先验信息：专家对物种偏好的信念
expert_prior <- c(0.6, 0.3, 0.1)  # 喜欢森林、草地、湿地的先验概率

# 观测数据：在不同栖息地中发现物种的次数
observations <- c(45, 20, 5)      # 在森林、草地、湿地中的观测次数
total_observations <- sum(observations)

# 计算似然函数（基于观测数据）
likelihood <- observations / total_observations

# 计算证据概率
evidence <- sum(expert_prior * likelihood)

# 贝叶斯更新
posterior <- (expert_prior * likelihood) / evidence

# 结果分析
results <- data.frame(
  Habitat = c("Forest", "Grassland", "Wetland"),
  Expert_Prior = expert_prior,
  Observed_Likelihood = likelihood,
  Bayesian_Posterior = posterior
)

print("贝叶斯物种分布模型结果:")
print(results)

# 计算信息增益（KL散度）
kl_divergence <- sum(posterior * log(posterior / expert_prior))
print(paste("KL散度（信息增益）:", round(kl_divergence, 4)))

# 贝叶斯因子计算
bayes_factor <- (posterior[1] / (1 - posterior[1])) / (expert_prior[1] / (1 - expert_prior[1]))
print(paste("贝叶斯因子（森林偏好）:", round(bayes_factor, 2)))
```

##### 风险评估与决策
```r
# 贝叶斯风险评估
set.seed(1515)

# 先验风险分布
risk_prior <- c(0.2, 0.5, 0.3)  # 低、中、高风险先验
names(risk_prior) <- c("Low", "Medium", "High")

# 新证据：气候指标异常
# 不同风险等级下出现异常的概率
anomaly_likelihood <- c(0.1, 0.4, 0.8)

# 观测到气候异常
observed_anomaly <- TRUE

# 贝叶斯更新
if (observed_anomaly) {
  evidence_prob <- sum(risk_prior * anomaly_likelihood)
  risk_posterior <- (risk_prior * anomaly_likelihood) / evidence_prob
} else {
  risk_posterior <- risk_prior  # 无新证据，后验=先验
}

# 决策分析：是否采取保护措施
protection_cost <- 100000
 damage_cost <- c(50000, 200000, 500000)  # 低、中、高风险下的损失

expected_damage <- sum(risk_posterior * damage_cost)
decision <- ifelse(expected_damage > protection_cost, "采取保护措施", "不采取措施")

print("贝叶斯风险评估与决策:")
print(paste("先验风险:", paste(round(risk_prior, 3), collapse = ", ")))
print(paste("后验风险:", paste(round(risk_posterior, 3), collapse = ", ")))
print(paste("预期损失:", round(expected_damage, 0)))
print(paste("保护成本:", protection_cost))
print(paste("决策:", decision))

# 敏感性分析
sensitivity_analysis <- function(anomaly_strength) {
  adjusted_likelihood <- anomaly_likelihood * anomaly_strength
  evidence_adj <- sum(risk_prior * adjusted_likelihood)
  posterior_adj <- (risk_prior * adjusted_likelihood) / evidence_adj
  expected_damage_adj <- sum(posterior_adj * damage_cost)
  return(expected_damage_adj)
}

anomaly_strengths <- seq(0.5, 2, 0.25)
damage_sensitivity <- sapply(anomaly_strengths, sensitivity_analysis)

plot(anomaly_strengths, damage_sensitivity, type = "b",
     xlab = "异常强度乘数", ylab = "预期损失",
     main = "贝叶斯风险敏感性分析")
abline(h = protection_cost, col = "red", lty = 2)
```

#### 贝叶斯计算与MCMC

##### 简单MCMC演示
```r
# 简单MCMC采样演示
simple_mcmc <- function(n_iterations, prior_mean, prior_sd, data, likelihood_sd) {
  # 初始化
  current_value <- prior_mean
  samples <- numeric(n_iterations)
  accepts <- 0
  
  for (i in 1:n_iterations) {
    # 建议新值
    proposal <- rnorm(1, current_value, 0.1)
    
    # 计算先验概率
    prior_current <- dnorm(current_value, prior_mean, prior_sd)
    prior_proposal <- dnorm(proposal, prior_mean, prior_sd)
    
    # 计算似然概率
    likelihood_current <- prod(dnorm(data, current_value, likelihood_sd))
    likelihood_proposal <- prod(dnorm(data, proposal, likelihood_sd))
    
    # 计算接受概率
    acceptance_ratio <- (prior_proposal * likelihood_proposal) / (prior_current * likelihood_current)
    acceptance_prob <- min(1, acceptance_ratio)
    
    # 决定是否接受
    if (runif(1) < acceptance_prob) {
      current_value <- proposal
      accepts <- accepts + 1
    }
    
    samples[i] <- current_value
  }
  
  acceptance_rate <- accepts / n_iterations
  return(list(samples = samples, acceptance_rate = acceptance_rate))
}

# 生成测试数据
true_value <- 5.0
observed_data <- rnorm(20, true_value, 1.0)

# 运行MCMC
mcmc_result <- simple_mcmc(5000, prior_mean = 0, prior_sd = 10, 
                           data = observed_data, likelihood_sd = 1.0)

print(paste("MCMC接受率:", round(mcmc_result$acceptance_rate, 3)))
print(paste("后验均值:", round(mean(mcmc_result$samples), 3)))
print(paste("真实值:", true_value))

# 绘制MCMC链和后验分布
par(mfrow = c(2, 1))
plot(mcmc_result$samples, type = "l", main = "MCMC链", xlab = "迭代", ylab = "参数值")
hist(mcmc_result$samples, breaks = 30, main = "后验分布", xlab = "参数值", freq = FALSE)
abline(v = true_value, col = "red", lwd = 2)
abline(v = mean(observed_data), col = "blue", lwd = 2, lty = 2)
legend("topright", legend = c("真实值", "样本均值"), col = c("red", "blue"), lty = 1:2)
```

##### 贝叶斯模型比较
```r
# 贝叶斯模型比较
set.seed(1616)

# 生成生态数据
time <- 1:50
# 真实模型：线性增长 + 季节效应
true_growth <- 0.5
season_effect <- 2 * sin(2 * pi * time / 12)
true_values <- 10 + true_growth * time + season_effect
observed_data <- true_values + rnorm(50, 0, 1.5)

# 定义两个候选模型
# 模型1: 只有线性趋势
model1_predict <- function(params, t) {
  params[1] + params[2] * t
}

# 模型2: 线性趋势 + 正弦季节效应
model2_predict <- function(params, t) {
  params[1] + params[2] * t + params[3] * sin(2 * pi * t / 12)
}

# 计算模型证据（近似）
calculate_evidence <- function(model_func, params_prior, data) {
  # 简单网格近似
  n_points <- 100
  evidence <- 0
  
  # 在参数空间采样
  for (i in 1:n_points) {
    params <- params_prior(i)
    predictions <- model_func(params, time)
    likelihood <- prod(dnorm(data, predictions, 1.5))
    evidence <- evidence + likelihood / n_points
  }
  
  return(evidence)
}

# 先验分布函数
prior1 <- function(i) c(runif(1, 5, 15), runif(1, 0, 1))
prior2 <- function(i) c(runif(1, 5, 15), runif(1, 0, 1), runif(1, 1, 3))

# 计算模型证据
evidence1 <- calculate_evidence(model1_predict, prior1, observed_data)
evidence2 <- calculate_evidence(model2_predict, prior2, observed_data)

# 贝叶斯因子
bayes_factor <- evidence2 / evidence1

print("贝叶斯模型比较:")
print(paste("模型1证据:", round(evidence1, 6)))
print(paste("模型2证据:", round(evidence2, 6)))
print(paste("贝叶斯因子（模型2/模型1）:", round(bayes_factor, 2)))

if (bayes_factor > 3) {
  print("强烈支持模型2（有季节效应）")
} else if (bayes_factor > 1) {
  print("微弱支持模型2")
} else if (bayes_factor > 1/3) {
  print("证据不足")
} else {
  print("支持模型1（无季节效应）")
}
```

#### 贝叶斯生态学实践指南

```r
# 贝叶斯分析实践指南
bayesian_guide <- data.frame(
  Step = c("1. 定义先验", "2. 构建似然", "3. 计算后验", "4. 模型检查", "5. 决策应用"),
  Description = c(
    "基于文献、专家知识或弱信息设定先验分布",
    "根据数据生成过程构建概率似然函数", 
    "使用解析方法或MCMC计算后验分布",
    "检查收敛性、预测准确性、敏感性",
    "基于后验分布进行预测和决策"
  ),
  Tools = c("文献调研、专家访谈", "概率分布、生态机制", "Stan、JAGS、自定义MCMC", "Rhat、trace plots、PPC", "决策理论、风险分析")
)

print("贝叶斯生态学分析实践指南:")
print(bayesian_guide)

# 常见先验分布选择
prior_distributions <- data.frame(
  Parameter_Type = c("概率", "正实数", "实数", "相关系数", "方差"),
  Recommended_Prior = c("Beta分布", "Gamma分布", "正态分布", "LKJ分布", "Half-Cauchy分布"),
  Example = c("Beta(1,1)", "Gamma(0.1,0.1)", "N(0,10)", "LKJ(2)", "Half-Cauchy(0,5)")
)

print("\n常见参数类型的先验分布选择:")
print(prior_distributions)

# 贝叶斯软件推荐
bayesian_software <- data.frame(
  Software = c("Stan", "JAGS", "PyMC3", "brms", "rstanarm"),
  Language = c("C++", "Bugs", "Python", "R", "R"),
  Features = c("高效Hamiltonian MC", "Gibbs采样", "概率编程", "R公式接口", "预构建模型"),
  Ecology_Applications = c("复杂生态模型", "传统贝叶斯", "机器学习整合", "回归模型", "快速原型")
)

print("\n贝叶斯分析软件推荐:")
print(bayesian_software)
```

## 随机变量与概率分布

### 生态学背景
概率和统计是生态学研究的数学基础。自然界中的生态现象具有随机性，如种子萌发率、动物存活率、物种出现频次等。理解随机变量和概率分布有助于我们建立合适的统计模型，正确解释生态学数据。

### 演示数据
```r
# 森林生态学调查数据示例
set.seed(123)

# 1. 离散数据
nest_success <- rbinom(100, size = 1, prob = 0.65)    # 100个巢穴的成功/失败记录
insect_count <- rpois(80, lambda = 8)                 # 80个样方的昆虫个体数
species_count <- rnbinom(60, size = 3, prob = 0.4)    # 60个样方的物种数（过度分散）

# 2. 连续数据  
tree_height <- rnorm(50, mean = 15, sd = 3)           # 50棵树的高度数据（正态）
tree_diameter <- rlnorm(50, meanlog = 2.5, sdlog = 0.7) # 50棵树的直径数据（对数正态）
biomass <- rgamma(40, shape = 4, rate = 0.8)          # 40个样方的生物量数据（伽马）

# 3. 比例数据
canopy_cover <- rbeta(30, shape1 = 3, shape2 = 2)     # 30个样方的冠层盖度
seed_germination <- rbeta(25, shape1 = 8, shape2 = 2) # 25批种子的萌发率
```

### 课堂演示过程

#### 1. 随机变量的概念
```r
# 什么是随机变量？
# 随机变量是随机现象结果的数值表示

# 创建一些生态学随机变量的例子
set.seed(123)

# 例子1：鸟类筑巢成功（二项分布）
# 假设每个巢穴成功概率为0.65
nest_trials <- 10
success_prob <- 0.65

# 模拟10个巢穴的结果
nest_results <- rbinom(nest_trials, size = 1, prob = success_prob)
print(paste("筑巢结果:", paste(nest_results, collapse = ", ")))
print(paste("成功率:", mean(nest_results)))

# 例子2：树木高度（正态分布）
tree_heights <- rnorm(20, mean = 15, sd = 3)
print("树木高度（米）:")
print(round(tree_heights, 1))
print(paste("平均高度:", round(mean(tree_heights), 2), "米"))
```

#### 2. 常见概率分布

##### 二项分布（Binomial Distribution）
```r
# 二项分布：n次独立试验中成功次数的分布
# 生态学应用：种子发芽、动物存活、物种出现等

# 参数：n（试验次数），p（成功概率）
n_seeds <- 20
germination_prob <- 0.75

# 模拟种子发芽实验
germinated_seeds <- rbinom(1000, size = n_seeds, prob = germination_prob)

# 计算理论均值和方差
theoretical_mean <- n_seeds * germination_prob
theoretical_var <- n_seeds * germination_prob * (1 - germination_prob)

print(paste("理论均值:", theoretical_mean))
print(paste("实际均值:", round(mean(germinated_seeds), 2)))
print(paste("理论方差:", theoretical_var))
print(paste("实际方差:", round(var(germinated_seeds), 2)))

# 可视化二项分布
hist(germinated_seeds, breaks = 30, 
     main = "种子发芽数量分布", 
     xlab = "发芽种子数", ylab = "频数",
     col = "lightblue")
abline(v = theoretical_mean, col = "red", lwd = 2, lty = 2)
```

##### 均匀分布（Uniform Distribution）
```r
# 均匀分布：最简单的基础分布
# 生态学应用：随机抽样、空间位置、环境梯度等

# 参数：a（下限），b（上限）
min_val <- 0
max_val <- 10

# 生成均匀分布数据
uniform_data <- runif(100, min = min_val, max = max_val)

# 描述统计
print(paste("样本均值:", round(mean(uniform_data), 2)))
print(paste("理论均值:", (min_val + max_val)/2))
print(paste("样本方差:", round(var(uniform_data), 2)))
print(paste("理论方差:", (max_val - min_val)^2/12))

# 均匀分布的特性
# 所有值在区间内等概率出现
within_range <- sum(uniform_data >= min_val & uniform_data <= max_val)
print(paste("在区间内的比例:", within_range/100))

# 可视化均匀分布
hist(uniform_data, breaks = 10, freq = FALSE,
     main = "均匀分布示例", 
     xlab = "数值", ylab = "密度",
     col = "lightblue")

# 添加理论均匀密度线
abline(h = 1/(max_val - min_val), col = "red", lwd = 2)
```

##### 正态分布（Normal Distribution）
```r
# 正态分布：连续变量的经典分布
# 生态学应用：生物量、身长、环境因子等连续测量

# 参数：μ（均值），σ（标准差）
mean_height <- 12
sd_height <- 2.5

# 生成树高数据
tree_heights <- rnorm(200, mean = mean_height, sd = sd_height)

# 描述统计
print(paste("样本均值:", round(mean(tree_heights), 2)))
print(paste("样本标准差:", round(sd(tree_heights), 2)))

# 正态分布的特性
# 68-95-99.7规则
within_1sd <- sum(abs(tree_heights - mean(tree_heights)) <= sd(tree_heights))
within_2sd <- sum(abs(tree_heights - mean(tree_heights)) <= 2*sd(tree_heights))

print(paste("1个标准差内的比例:", round(within_1sd/200, 3)))
print(paste("2个标准差内的比例:", round(within_2sd/200, 3)))

# 可视化正态分布
hist(tree_heights, breaks = 20, freq = FALSE,
     main = "树木高度分布", 
     xlab = "高度(米)", ylab = "密度",
     col = "lightgreen")

# 添加理论正态曲线
x_vals <- seq(5, 20, 0.1)
y_vals <- dnorm(x_vals, mean = mean_height, sd = sd_height)
lines(x_vals, y_vals, col = "red", lwd = 2)
```

##### 泊松分布（Poisson Distribution）
```r
# 泊松分布：单位时间/空间内事件发生次数
# 生态学应用：物种个体数、疾病发生率等计数数据

# 参数：λ（平均发生率）
lambda_insects <- 6

# 模拟昆虫计数
insect_counts <- rpois(100, lambda = lambda_insects)

# 统计特性
print(paste("理论均值:", lambda_insects))
print(paste("实际均值:", round(mean(insect_counts), 2)))
print(paste("理论方差:", lambda_insects))
print(paste("实际方差:", round(var(insect_counts), 2)))

# 泊松分布的特点：均值 = 方差
print(paste("均值/方差比:", round(mean(insect_counts)/var(insect_counts), 3)))

# 可视化泊松分布
hist(insect_counts, breaks = max(insect_counts), 
     main = "昆虫个体数分布", 
     xlab = "个体数", ylab = "频数",
     col = "yellow")
```

##### 负二项分布（Negative Binomial Distribution）
```r
# 负二项分布：过度分散计数数据的分布
# 生态学应用：森林物种计数、病虫害发生次数等

# 参数：size（成功次数），prob（成功概率）
size_param <- 5
prob_param <- 0.3

# 模拟过度分散的物种计数数据
overdispersed_counts <- rnbinom(100, size = size_param, prob = prob_param)

# 统计特性
print(paste("理论均值:", size_param*(1-prob_param)/prob_param))
print(paste("实际均值:", round(mean(overdispersed_counts), 2)))
print(paste("理论方差:", size_param*(1-prob_param)/prob_param^2))
print(paste("实际方差:", round(var(overdispersed_counts), 2)))

# 与泊松分布比较
poisson_counts <- rpois(100, lambda = mean(overdispersed_counts))
print(paste("泊松方差:", round(var(poisson_counts), 2)))
print(paste("过度分散指数:", round(var(overdispersed_counts)/mean(overdispersed_counts), 2)))

# 可视化负二项分布
hist(overdispersed_counts, breaks = 20, 
     main = "过度分散的物种计数分布", 
     xlab = "个体数", ylab = "频数",
     col = "orange")
```

##### 对数正态分布（Lognormal Distribution）
```r
# 对数正态分布：右偏连续数据的分布
# 生态学应用：森林生物量、树木直径、种子重量等

# 参数：对数尺度上的均值和标准差
meanlog <- 2.5
sdlog <- 0.8

# 模拟树木直径数据
tree_diameters <- rlnorm(200, meanlog = meanlog, sdlog = sdlog)

# 描述统计
print(paste("样本均值:", round(mean(tree_diameters), 2)))
print(paste("样本标准差:", round(sd(tree_diameters), 2)))
print(paste("偏度:", round(moments::skewness(tree_diameters), 2)))

# 理论均值和方差
theoretical_mean <- exp(meanlog + sdlog^2/2)
theoretical_var <- (exp(sdlog^2) - 1) * exp(2*meanlog + sdlog^2)

print(paste("理论均值:", round(theoretical_mean, 2)))
print(paste("理论方差:", round(theoretical_var, 2)))

# 可视化对数正态分布
hist(tree_diameters, breaks = 30, freq = FALSE,
     main = "树木直径分布（对数正态）", 
     xlab = "直径(cm)", ylab = "密度",
     col = "lightblue")

# 添加理论对数正态曲线
x_vals <- seq(0, max(tree_diameters), 0.1)
y_vals <- dlnorm(x_vals, meanlog = meanlog, sdlog = sdlog)
lines(x_vals, y_vals, col = "red", lwd = 2)
```

#### 3. R中的概率分布函数
```r
# R中每个分布都有4个函数：
# d*(): 概率密度/质量函数
# p*(): 累积分布函数
# q*(): 分位数函数
# r*(): 随机数生成

# 以正态分布为例
mu <- 15
sigma <- 3

# 1. 概率密度函数 dnorm()
x <- 15
density_at_15 <- dnorm(x, mean = mu, sd = sigma)
print(paste("在x=15处的密度:", round(density_at_15, 4)))

# 2. 累积分布函数 pnorm()
prob_less_than_18 <- pnorm(18, mean = mu, sd = sigma)
print(paste("P(X < 18):", round(prob_less_than_18, 3)))

# 3. 分位数函数 qnorm()
percentile_95 <- qnorm(0.95, mean = mu, sd = sigma)
print(paste("95%分位数:", round(percentile_95, 2)))

# 4. 随机数生成 rnorm()
random_values <- rnorm(10, mean = mu, sd = sigma)
print("10个随机值:")
print(round(random_values, 2))
```

#### 4. 中心极限定理演示
```r
# 中心极限定理：样本均值的分布趋于正态分布
# 生态学意义：大样本下统计推断的理论基础

set.seed(789)

# 从均匀分布中抽样
uniform_samples <- replicate(1000, {
  sample_means <- replicate(30, mean(runif(50, 0, 10)))
  mean(sample_means)
})

# 从指数分布中抽样
exponential_samples <- replicate(1000, {
  sample_means <- replicate(30, mean(rexp(50, rate = 0.5)))
  mean(sample_means)
})

# 可视化中心极限定理效果
par(mfrow = c(2, 2))

# 原始均匀分布
hist(runif(1000, 0, 10), breaks = 20, main = "均匀分布原始数据", 
     xlab = "数值", col = "lightblue")

# 均匀分布样本均值的分布
hist(uniform_samples, breaks = 20, main = "均匀分布样本均值分布", 
     xlab = "样本均值", col = "lightgreen")

# 原始指数分布
hist(rexp(1000, rate = 0.5), breaks = 20, main = "指数分布原始数据", 
     xlab = "数值", col = "lightcoral")

# 指数分布样本均值的分布
hist(exponential_samples, breaks = 20, main = "指数分布样本均值分布", 
     xlab = "样本均值", col = "lightyellow")

par(mfrow = c(1, 1))

# 检验样本均值分布的正态性
shapiro_uniform <- shapiro.test(uniform_samples)
shapiro_exponential <- shapiro.test(exponential_samples)

print(paste("均匀分布样本均值的Shapiro-Wilk p值:", round(shapiro_uniform$p.value, 4)))
print(paste("指数分布样本均值的Shapiro-Wilk p值:", round(shapiro_exponential$p.value, 4)))
```

#### 5. 分布的选择与拟合
```r
# 如何为生态数据选择合适的分布？

# 创建不同类型的生态数据
set.seed(456)

# 计数数据（泊松分布）
species_counts <- rpois(50, lambda = 12)

# 连续数据（正态分布）
leaf_lengths <- rnorm(50, mean = 8, sd = 1.5)

# 比例数据（贝塔分布或logit变换）
cover_percentages <- rbeta(50, shape1 = 3, shape2 = 2) * 100

# 检验正态性
shapiro_test <- shapiro.test(leaf_lengths)
print(paste("Shapiro-Wilk检验p值:", round(shapiro_test$p.value, 4)))

# QQ图检验正态性
qqnorm(leaf_lengths, main = "叶长正态性检验")
qqline(leaf_lengths, col = "red")

# 直方图 vs 理论分布比较
par(mfrow = c(2, 2))

# 泊松分布拟合
hist(species_counts, breaks = 15, freq = FALSE, 
     main = "物种数量分布", col = "lightblue")
x_pois <- 0:max(species_counts)
y_pois <- dpois(x_pois, lambda = mean(species_counts))
points(x_pois, y_pois, col = "red", pch = 19)

# 正态分布拟合
hist(leaf_lengths, breaks = 15, freq = FALSE,
     main = "叶长分布", col = "lightgreen")
x_norm <- seq(min(leaf_lengths), max(leaf_lengths), 0.1)
y_norm <- dnorm(x_norm, mean = mean(leaf_lengths), sd = sd(leaf_lengths))
lines(x_norm, y_norm, col = "red", lwd = 2)

par(mfrow = c(1, 1))
```

### 统计知识点详解

#### 1. 随机变量基础概念

##### 离散随机变量
- **定义**：取值为可数个的随机变量
- **生态学例子**：
  - 巢穴中雏鸟数量
  - 样方中物种个数
  - 一天内观察到的动物次数
- **常用分布**：二项分布、泊松分布、几何分布

##### 连续随机变量
- **定义**：取值在连续区间内的随机变量
- **生态学例子**：
  - 动物体重
  - 树木高度
  - 环境温度
- **常用分布**：正态分布、对数正态分布、伽马分布

#### 2. 重要概率分布详解

##### 二项分布 B(n, p)
- **参数**：
  - n：独立试验次数
  - p：每次试验成功概率
- **性质**：
  - E(X) = np
  - Var(X) = np(1-p)
- **R函数**：
  - `dbinom(x, size, prob)`：概率质量函数
  - `pbinom(q, size, prob)`：累积分布函数
  - `qbinom(p, size, prob)`：分位数函数
  - `rbinom(n, size, prob)`：随机数生成

##### 均匀分布 Uniform(a, b)
- **参数**：
  - a：下限
  - b：上限
- **性质**：
  - 在区间[a,b]上等概率分布
  - 概率密度函数为常数 1/(b-a)
  - 均值为 (a+b)/2，方差为 (b-a)²/12
- **R函数**：
  - `dunif(x, min, max)`：概率密度函数
  - `punif(q, min, max)`：累积分布函数
  - `qunif(p, min, max)`：分位数函数
  - `runif(n, min, max)`：随机数生成

##### 正态分布 N(μ, σ²)
- **参数**：
  - μ：均值
  - σ²：方差
- **性质**：
  - 对称分布
  - 68-95-99.7规则
  - 中心极限定理的基础
- **R函数**：
  - `dnorm(x, mean, sd)`：概率密度函数
  - `pnorm(q, mean, sd)`：累积分布函数
  - `qnorm(p, mean, sd)`：分位数函数
  - `rnorm(n, mean, sd)`：随机数生成

##### 泊松分布 Poisson(λ)
- **参数**：
  - λ：平均发生率
- **性质**：
  - E(X) = Var(X) = λ
  - 适用于稀有事件计数
- **R函数**：
  - `dpois(x, lambda)`：概率质量函数
  - `ppois(q, lambda)`：累积分布函数
  - `qpois(p, lambda)`：分位数函数
  - `rpois(n, lambda)`：随机数生成

##### 负二项分布 Negative Binomial(r, p)
- **参数**：
  - r：成功次数
  - p：成功概率
- **性质**：
  - E(X) = r(1-p)/p
  - Var(X) = r(1-p)/p²
  - 适用于过度分散的计数数据（森林物种计数常见）
- **R函数**：
  - `dnbinom(x, size, prob)`：概率质量函数
  - `pnbinom(q, size, prob)`：累积分布函数
  - `qnbinom(p, size, prob)`：分位数函数
  - `rnbinom(n, size, prob)`：随机数生成

##### 对数正态分布 Lognormal(μ, σ)
- **参数**：
  - μ：对数尺度上的均值
  - σ：对数尺度上的标准差
- **性质**：
  - 右偏分布，适用于森林生物量、树木直径等
  - 如果 Y ~ N(μ, σ²)，则 X = exp(Y) ~ Lognormal(μ, σ)
- **R函数**：
  - `dlnorm(x, meanlog, sdlog)`：概率密度函数
  - `plnorm(q, meanlog, sdlog)`：累积分布函数
  - `qlnorm(p, meanlog, sdlog)`：分位数函数
  - `rlnorm(n, meanlog, sdlog)`：随机数生成

##### 伽马分布 Gamma(α, β)
- **参数**：
  - α：形状参数
  - β：速率参数
- **性质**：
  - 适用于正值连续数据
  - 指数分布和卡方分布的特例
- **R函数**：
  - `dgamma(x, shape, rate)`：概率密度函数
  - `pgamma(q, shape, rate)`：累积分布函数
  - `qgamma(p, shape, rate)`：分位数函数
  - `rgamma(n, shape, rate)`：随机数生成

##### 贝塔分布 Beta(α, β)
- **参数**：
  - α：形状参数1
  - β：形状参数2
- **性质**：
  - 定义在[0,1]区间
  - 适用于比例、概率数据
- **R函数**：
  - `dbeta(x, shape1, shape2)`：概率密度函数
  - `pbeta(q, shape1, shape2)`：累积分布函数
  - `qbeta(p, shape1, shape2)`：分位数函数
  - `rbeta(n, shape1, shape2)`：随机数生成

##### 威布尔分布 Weibull(k, λ)
- **参数**：
  - k：形状参数（决定分布形态）
  - λ：尺度参数（决定分布范围）
- **性质**：
  - 适用于生存分析、寿命数据
  - 当k=1时退化为指数分布
  - 当k=2时近似瑞利分布
  - 风险函数（失效率）随时间变化
- **R函数**：
  - `dweibull(x, shape, scale)`：概率密度函数
  - `pweibull(q, shape, scale)`：累积分布函数
  - `qweibull(p, shape, scale)`：分位数函数
  - `rweibull(n, shape, scale)`：随机数生成

#### 3. 中心极限定理详解

##### 中心极限定理（Central Limit Theorem）
- **定义**：从任意分布中抽取足够大的样本，其样本均值的分布趋近于正态分布
- **条件**：
  - 样本量足够大（通常n ≥ 30）
  - 样本独立同分布
- **生态学意义**：
  - 为大样本统计推断提供理论基础
  - 即使原始数据非正态，样本均值也可用正态方法分析
  - 适用于种群均值估计、生物量估算等

##### 分布检验方法

##### Shapiro-Wilk正态性检验
- **函数**：`shapiro.test(x)`
- **假设**：
  - H₀：数据来自正态分布
  - H₁：数据不来自正态分布
- **判断标准**：p < 0.05拒绝正态性假设

##### Q-Q图（Quantile-Quantile Plot）
- **函数**：`qqnorm(x)`, `qqline(x)`
- **原理**：比较样本分位数与理论分位数
- **判断**：点越接近直线，越符合正态分布

#### 4. 生态学中的分布选择指南

##### 计数数据
- **泊松分布**：个体数、物种数等（均值≈方差）
- **负二项分布**：过度分散的计数数据（方差>均值，森林物种计数常见）
- **二项分布**：成功/失败类型数据（固定试验次数）
- **零膨胀分布**：零值过多的计数数据（需要专门包如pscl）

##### 连续数据
- **均匀分布**：随机抽样、空间位置、环境梯度等（等概率分布）
- **正态分布**：生物量、长度等对称分布数据
- **对数正态分布**：右偏分布数据（森林生物量、树木直径、种子重量）
- **伽马分布**：正值连续数据（存活时间、生长速率）
- **威布尔分布**：生存分析、寿命分布、时间事件数据（动物寿命、种子萌发时间、设备故障时间）

##### 比例数据
- **贝塔分布**：0-1之间的比例数据（盖度、频率）
- **logit变换**：将比例转换为正态分布

##### 森林生态学特殊考虑
- **空间自相关**：森林数据常存在空间依赖性
- **层次结构**：样地-树木-个体的嵌套结构
- **混合分布**：异质森林环境可能产生多峰分布
- **截断数据**：调查中的最小测量阈值影响

### 课后练习

**题目**：某森林生态系统调查收集了以下数据：
```r
# 50个样方的鸟类物种数
bird_species <- c(5, 7, 8, 6, 9, 8, 7, 6, 8, 7, 6, 9, 8, 7, 6,
                  8, 9, 7, 6, 8, 7, 9, 8, 6, 7, 8, 9, 6, 7, 8,
                  9, 8, 7, 6, 9, 8, 7, 6, 8, 9, 7, 8, 6, 9, 8,
                  7, 6, 8, 9, 7)

# 30个植物个体的叶片长度（cm）
leaf_length <- c(12.3, 14.1, 13.8, 15.2, 12.9, 14.7, 13.5, 14.9, 13.1, 15.1,
                 14.3, 13.7, 14.8, 13.2, 14.5, 13.9, 14.2, 13.4, 15.0, 13.6,
                 14.4, 13.8, 14.6, 13.3, 14.1, 13.7, 14.9, 13.5, 14.3, 13.9)

# 100次种子萌发试验的成功次数（每次试验20粒种子）
germination_success <- c(16, 15, 18, 17, 14, 16, 15, 17, 16, 18, 
                         15, 16, 17, 15, 16, 18, 16, 17, 15, 16,
                         17, 16, 15, 18, 16, 17, 15, 16, 18, 17,
                         16, 15, 17, 16, 18, 15, 16, 17, 16, 18,
                         17, 16, 15, 18, 16, 17, 15, 16, 17, 18,
                         16, 15, 17, 16, 18, 15, 16, 17, 16, 18,
                         17, 16, 15, 17, 16, 18, 15, 16, 17, 16,
                         18, 17, 16, 15, 17, 16, 18, 15, 16, 17,
                         16, 18, 17, 16, 15, 17, 16, 18, 15, 16,
                         17, 16, 18, 17, 16, 15, 17, 16, 18, 15)

# 新增森林生态数据：
# 40棵树木的直径（cm）
tree_diameter <- c(12.3, 15.8, 22.1, 18.5, 14.2, 25.6, 19.8, 16.7, 28.3, 21.4,
                   13.9, 17.2, 24.8, 20.1, 15.3, 26.9, 18.7, 23.5, 16.8, 27.4,
                   14.7, 19.2, 22.8, 17.6, 29.1, 20.9, 15.8, 24.3, 18.2, 26.7,
                   13.5, 16.9, 21.7, 19.3, 25.4, 17.8, 23.9, 15.1, 27.8, 20.5)

# 30个样方的林下植物盖度（%）
understory_cover <- c(35, 28, 42, 19, 53, 37, 24, 46, 31, 58,
                      22, 39, 27, 44, 33, 49, 26, 41, 36, 51,
                      29, 45, 38, 23, 47, 32, 56, 25, 43, 34)

# 25个样方的枯落物厚度（cm）  
litter_depth <- c(2.3, 3.8, 1.9, 4.2, 2.7, 3.5, 2.1, 4.8, 3.2, 2.9,
                  4.1, 2.5, 3.7, 2.8, 4.5, 3.1, 2.4, 4.3, 3.6, 2.6,
                  4.0, 3.3, 2.2, 4.4, 3.4)
```

请完成（使用概率分布理论和R函数）：
1. **描述统计**：计算所有数据的均值、方差、范围（使用已学的统计函数）
2. **分布识别**：根据数据特征判断每组数据可能服从的分布类型
3. **正态性检验**：对叶片长度、树木直径、枯落物厚度数据进行Shapiro-Wilk检验
4. **分布拟合**：
   - 为鸟类物种数拟合泊松分布和负二项分布，比较拟合优度
   - 为萌发成功次数拟合二项分布，估计萌发概率
   - 为树木直径拟合正态分布和对数正态分布，比较哪种更合适
   - 为林下植物盖度拟合贝塔分布
5. **可视化**：绘制每组数据的直方图，并叠加理论分布曲线
6. **概率计算**：
   - 计算观察到5种以下鸟类的概率
   - 计算树木直径超过25cm的概率
   - 计算林下植物盖度低于30%的概率
   - 计算萌发成功数超过17的概率
7. **生态解释**：解释每种分布在森林生态学中的具体应用意义
8. **分布比较**：对于过度分散的计数数据，比较泊松分布和负二项分布的适用性
